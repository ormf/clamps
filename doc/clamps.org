#+TITLE: Clamps Packages
#+AUTHOR: Orm Finnendahl
#+LANGUAGE: en
#+OPTIONS: html5-fancy:t
#+OPTIONS: num:nil
#+OPTIONS: toc:4 h:4 html-multipage-join-empty-bodies:t
#+OPTIONS: html-multipage-split-level:toc
#+OPTIONS: html-multipage-toc-to-top:t
#+OPTIONS: html-multipage-export-directory:html/clamps-doc/clamps
#+OPTIONS: html-multipage-open:nil
#+OPTIONS: html-preamble:"<a class=\"top-menu\" href=\"../overview/index.html\">Overview</a>\n<a class=\"top-menu top-menu-active\" href=\"./index.html\">Clamps Packages</a>\n<a class=\"top-menu\" href=\"../cm-dict/index.html\">CM Dictionary</a>\n<a class=\"top-menu\" href=\"../clamps-dict/index.html\">Clamps Dictionary</a>\n<a class=\"top-menu\" href=\"../fomus/index.html\">Fomus</a>\n"
#+OPTIONS: html-multipage-postamble-position:bottom
#+OPTIONS: html-postamble:nil
#+OPTIONS: html-multipage-include-default-style:nil
#+HTML_DOCTYPE: xhtml5
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/clamps.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/htmlize.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/themes.css" />
#+HTML_HEAD: <link href="./pagefind/pagefind-ui.css" rel="stylesheet">
#+HTML_HEAD: <script src="./pagefind/pagefind-ui.js"></script>
#+HTML_HEAD: <script src="../js/clamps-doc.js"></script>
# #+SETUPFILE: theme-readtheorg-local.setup
#+BEGIN_SRC emacs-lisp :exports results :results: none
    (load (format "%s%s" (file-name-directory (buffer-file-name))
                  "../extra/elisp/clamps-dict.el"))
    (load (format "%s%s" (file-name-directory (buffer-file-name))
                  "../extra/elisp/clamps-overview-lookup.el"))
    (defun export-clamps-syms (s backend info)
        (message "exporting clamps syms")
        (save-excursion
        (with-temp-buffer 
          (insert "(defvar *clamps-doc-symbols*)
    (setq *clamps-doc-symbols* (make-vector 63 0))
    (mapcar
       (lambda (entry)
         (let ((symbol (intern (car entry)
      			 ,*clamps-doc-symbols*)))
           (if (boundp symbol)
      	 (push (cadr entry) (symbol-value symbol))
             (set symbol (cdr entry)))))
       '(\n")
          (mapcar
           (lambda (entry)
             (insert
              (format "   (\"%s\" \"clamps/%s\")\n"
                      (org-html-element-title (car entry))
                      (plist-get (cdr entry) :href))))
           (cl-remove-if
            (lambda (x) (= 1 (plist-get (cdr x) :relative-level)))
            (plist-get info :multipage-toc-lookup)))
          (insert "))\n")
          (write-region (point-min) (point-max) "../extra/elisp/clamps-lookup.el"))
        (load (format "%s%s" (file-name-directory (buffer-file-name))
                   "../extra/elisp/clamps-lookup.el"))
        )
        s)
#+END_SRC
#+BIND: org-export-filter-multipage-functions (export-clamps-syms)
#+BIND: org-html-htmlize-output-type css
#+BIND: org-html-table-use-header-tags-for-first-column nil
#  #:\([^ ]+\) →    - [[dict:\1][\1]]


* General
** Clamps Packages Overview
*** Package Naming
   The additional packages developed for clamps serve different
   purposes, reflected in their name.

   - Packages implementing basic functionalities. Their name starts
     with /cl-/

   - Packages extending Common Music. Their name starts with /cm-/

   - Packages adding dsp related functionality. Their name contains
     /cuda/ or /incudine/.

   - Packages adding GUI functionality. Their name contains /clog/.

   Note that there are packages with similar names, like /cl-sfz/ or
   /cm-sfz/. The /cl-/ part is a more general implementation of basic
   functionality, while the /cm-/ part adds the specific extensions
   for the integration into Common Music.
*** Reading the Documentation
    The Clamps Packages Documentation aims to explain the concepts of
    the different parts of Clamps with some examples. For that reason,
    the table of contents is ordered systematically.

    Although each of the chapters can be considered an introduction to
    exemplify how to use the part it describes, it is not a thorough
    presentation of all components of the API of the package. It
    should nevertheless provide enough information to get a rough
    understanding of the concepts to be able to start using it.

    The [[../clamps-dict/index.html][Clamps Dictionary]] is the place to go to get a more complete
    picture of the API. The sections of the Clamps Package
    Documentation provide links to the dictionary in many places.

    The reader is encouraged to go back and forth between these
    documentation sources, use the cross-references in the dictionary,
    or even consult the source code.

    Due to this open concept there is no preferred sequence to read
    the Clamps Packages Documentation. Nevertheless, some parts depend
    on the knowledge of other parts of the documentation. As an
    example, the [[cm-sfz]] part can only be understood, when the concept
    of the [[cl-sfz]] package is known.

    Below is a graph of dependencies of the clamps packages. External
    packages are colored with a light red background. Although not
    strictly required, it might be advisable or sometimes even
    necessary to follow the arrows when reading through the
    documentation. The reader may construct her or his individual
    reading path from this graph according to personal preferences and
    interests.
    #+attr_html: :width 100%
    #+CAPTION: Dependencies between clamps packages
    [[./img/clamps-dependencies.svg]]  
    
** clamps
*** Symbols
   The clamps package imports most common music and incudine symbols.
   They can be used without prepending the package name as if being in
   the /:cm/ or /:incudine.scratch/ package. Not imported are the
   symbols of /:clog/ (with some exceptions). In addition clamps
   imports all symbols from clamps packages which extend the
   functionality of Common Music, Incudine or CLOG, documented in the
   [[./index.html][Clamps Packages]] section.
   
   The clamps package exports all exported symbols from its internal
   packages plus the imported symbols of CM. It does not export the
   symbols imported from incudine. As a rule of thumb, all symbols
   present in the [[../clamps-dict/index.html][Clamps Dictionary]] should be available from another
   package when issuing /(use-package :clamps)/ in that package:

   #+BEGIN_SRC lisp
     (ql:quickload :clamps)

     (defpackage :test
       (:use :clamps :cl))

     (in-package :test)

     (clamps)

     (sprout
      (process
        with repeats = 32
        for x from 0 to 1 by (/ (1- repeats))
        for dtime = (n-exp (interp x 0 0 0.3 1 0.7 1 1 0) 0.5 0.04)
        output (new sfz :keynum (+ 74 (n-lin-dev (interp x 0 0 0.5 0.1 1 1) 28.0)) :duration 0.1)
        wait dtime))

   #+END_SRC
   
*** Startup
    :PROPERTIES:
    :CUSTOM_ID: clamps-startup
    :END:
    The clamps package is loaded from the REPL using quicklisp:
    #+BEGIN_SRC lisp
      CL-USER> (ql:quickload :clamps)
    #+END_SRC
    To startup MIDI, Networking, DSP and the GUI, use the [[dict:clamps][clamps]]
    function:
    #+BEGIN_SRC lisp
     CL-USER> (clamps)
     warn: closing midi streams

     warn: #<JACKMIDI:input-STREAM "midi_in_1">
     warn: #<JACKMIDI:output-STREAM "midi_out_1">
     midi initialized!
     mag: 123.0d0 sr: 44100 fs: 441 ws: 1765 partials: 42 frames: 253 MaxAmp: 0.19512822211922679d0 MaxFrq: 19762.520188644547d0 Dur: 2.5113378684807257d0 Type: 4
     Loading sound...
     Optimizing load sound...
     Getting amplitude and frequency averages...
     Transferring noise energy to partials...
     Done!(re)starting gui...
     starting webserver at /tmp/www
     Hunchentoot server is started.
     Listening on 0.0.0.0:54619.
     HTTP listening on    : 0.0.0.0:54619
     HTML root            : /tmp/www/
     SSL                  : no
     SSL Key File         : nil
     SSL Cert File        : nil
     Long poll first      : no
     Boot function added  : no
     Boot html source use : compiled version, when no file
     Boot js source use   : compiled version
     Boot file for path / : /start.html

      /\\\          
     ---\\\---------
     ----\\\-------- CLAMPS
     ----/\\\------- Common Lisp Aided Music Production System
     ---/--\\\------ Version 0.0.1
     --/----\\\-----
      /      \\\/   

     ; No values
     clamps> 
    #+END_SRC
*** Emacs Shortcuts
    The following emacs shorctus are defined when working with Clamps:

    - /<C-c M-.>/ Start DSP processing (equivalent to /(rt-start)/)

    - /<C-c C-.>/ Stop DSP processing (equivalent to /(rt-stop)/)

    - /C-./ Stop all currently running dsps in /group 200/ and clear
      the Incudine scheduler.
*** GUI
    The GUI can be opened using the [[dict:gui][gui]] function. Calling this
    function will open the [[dict:clamps-base-url][clamps-base-url]] in a browser. It will
    initially display an empty page with a blue-grey background. To
    add elements to this page see [[clog-dsp-widgets]].

   #+attr_html: :width 80%
   #+CAPTION: Clamps GUI after startup
   [[./img/clamps-gui.png]]   
*** Meter Display
   To display VU Meters of the first 8 inputs and outputs of Incudine,
   call the [[dict:meters][meters]] function. It will open the page
   /<clamps-base-url>/meters/ in a Browser and display the following
   image:

   #+attr_html: :width 80%
   #+CAPTION: Clamps Meters display
   [[./img/meters.png]]
* Midi
** cl-midictl
   cl-midictl implements the basic infrastructure for dealing with
   MIDI in/output, a registry for midi-controllers and implements
   basic classes for midi-controllers.
*** Opening MIDI Ports
    Before being able to work with MIDI in/output in Clamps, its MIDI
    Ports have to get opened. Clamps uses the function [[dict:rts][rts]] to
    open the ports, which is called by the [[dict:clamps][clamps]] function at
    the beginning of the session. If realtime processing is
    activated[fn:1], the ports should appear in JACK.
*** MIDI Output
    Once the ports have been opened and an external program or
    hardware device has been connected to Incudine's JACK ports,
    issuing any MIDI output command will send the MIDI events to the
    program/device:

    #+BEGIN_SRC lisp
      ;; Send a midi note with keynum 60 and duration 0.5 seconds to Incudine's Midi Output

      (in-package :clamps)

      (output (new midi)) ; => ; No values

      ;; Send 10 midi events with random keynums:

      (loop
        repeat 10
        for time from 0 by 0.1
        do (sprout (new midi :time time :keynum (between 49 82))))
    #+END_SRC

*** MIDI Input
**** Receiving and handling MIDI Input
     After the Ports have been opened, MIDI input handling is started
     using the function [[dict:start-midi-receive][start-midi-receive]], which gets called
     automatically on startup using the [[dict:clamps][clamps]] function. MIDI input
     handling can be suspended using the [[dict:stop-midi-receive][stop-midi-receive]]
     function. Note that this will not close the MIDI ports, so
     connections to external devices or programs will be persistent. A
     later call to [[dict:start-midi-receive][start-midi-receive]] will continue to process MIDI
     input.

     Handling MIDI input in Clamps is done in 3 different stages:

     - All note and cc input is captured in the special variables
       *​midi-cc-state​* and *​midi-note-state​*. Both contain a
       2-dimensional array of 16x128 [[The ref-object class][ref-objects]] which capture the
       last received values of the 128 controller numbers or note
       numbers of all 16 MIDI channels. [[overview:Code Inspection][Inspect]] this value to see the
       current state of the MIDI input of Clamps.

     - In addition two other special variables, *​midi-cc-fns​* and
       *​midi-note-fns* contain 16x128 lists, intially empty. When
       receiving MIDI cc or MIDI note input, Clamps will address these
       arrays and call all functions stored in the list of the
       corresponding channel and CC number or keynum with the received
       controller value or note velocity as arguments.
      
     - At last, the #'handle-midi-in method of all midi controller
       instances registered with the function [[dict:add-midi-controller][add-midi-controller]] will
       get called.

**** Example using *​midi-cc-fns​*
     Let's show this in action. We want to attach behaviour when
     controller 1 of MIDI channel 1 is moved. One way is to use the
     *​midi-cc-fns​* variable like this:
     #+BEGIN_SRC lisp
       ;; add a function to the slot of *midi-cc-fns* corresponding to
       ;; the desired CC number and MIDI channel

       (push
        (lambda (cc-val)
          (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 1" cc-val))
        (aref (aref *midi-cc-fns* 0) 0))
       
       ;; => (#<function (lambda (cc-val)) {557AF50B}>)

       #+END_SRC
     When a MIDI controller outputting to MIDI channel 1 is connected
     to the JACK input of Incudine, moving controller 1 will print
     something like the following in the REPL:
     #+BEGIN_SRC lisp

       warn: Received CC Value 46 on Midi Channel 1 and CC Number 1
       warn: Received CC Value 47 on Midi Channel 1 and CC Number 1
       warn: Received CC Value 48 on Midi Channel 1 and CC Number 1
       warn: Received CC Value 49 on Midi Channel 1 and CC Number 1

       #+END_SRC

     In order to avoid the nested aref calls and the push, a couple of
     convenience functions have been added to cl-midictl. Rather than
     using zero-based numbers for the MIDI channel and CC number in
     the array references, those numbers start counting from 1 as
     common in most programs and hardware controllers.

     The following call is equivalent to the call above:
     #+BEGIN_SRC lisp

       (add-midi-cc-fn
        (lambda (ccval)
          (msg :warn
                "Received CC Value ~a on Midi Channel 1 and CC Number 1"
                ccval))
        1 1)

       ;; => (#<function (lambda (cc-val)) {564DA61B}>)

      #+END_SRC

     In a similar fashion the following functions are defined for
     convenience:

     - [[dict:show-midi-cc-fns][show-midi-cc-fns]]
     - [[dict:remove-midi-cc-fns][remove-midi-cc-fns]]
     - [[dict:remove-all-channel-midi-cc-fns][remove-all-channel-midi-cc-fns]]
     - [[dict:remove-all-midi-cc-fns][remove-all-midi-cc-fns]]

     Check their documentation how they are used.
**** Example using *​midi-cc-state​*
     The exact same behaviour can be achieved using
     *​midi-cc-state​*​. As mentioned before, the values received for all
     128 CC Numbers on all 16 MIDI Channels are registered in [[The ref-object
      class][ref-objects]] in the [[dict:#midi-cc-state][*​midi-cc-state​*]] array. By attaching a [[watch]]
     function to any of them the same behaviour as in the previous
     example can be achieved:
     #+BEGIN_SRC lisp
       ;; define a storage for removal of the watch relations
       (defparameter *unwatch* nil)

       (push
        (watch
         (lambda ()
           (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 1"
                 (get-val (aref (aref *midi-cc-state* 0) 0)))))
        *unwatch*)

       ;; => (#<function (lambda () :in watch) {1003126D9B}>)

     #+END_SRC
     Note that the function supplied to the /watch/ function has no
     arguments: The CC value is obtained by using the #'get-val
     function in the function body.

     To remove the connection between the MIDI controller and the
     watch function, the function returned by the call to /watch/ has
     to be called. This can be done like this:
     #+BEGIN_SRC lisp
       ;; remove "connections"

       (mapc #'funcall *unwatch*)

       ;; => (#<function (lambda () :in watch) {1003126D9B}>)

       ;; clear the *unwatch* list

       (setf *unwatch* nil) ; => nil

     #+END_SRC

     Again there is a convenience function for accessing the
     *​midi-cc-state​* of Clamps called [[dict:ccin][ccin]]. The function gets the CC
     Number and the MIDI channel as argument (both counting from 1)
     and returns the current value of that controller. The MIDI
     channel is optional and defaults to the special variable
     *​global-midi-channel​*.

     Using [[dict:ccin][ccin]], the example above can be rewritten like this:
     #+BEGIN_SRC lisp
       (push
        (watch
         (lambda ()
           (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 1"
                 (ccin 1 1))))
        *unwatch*)

       ;; => (#<function (lambda () :in watch) {100981F52B}>)

     #+END_SRC

     As it can be quite confusing, when establishing connections
     between MIDI CC input and actions triggered by it dynamically
     over the course of a session, it is advisable to establish a
     bookkeeping infrastructure, which makes it easy to restart a
     session at any time. Here are examples for both cases:
     #+BEGIN_SRC lisp
       ;; using *midi-cc-fns*

       (defun init-connections ()
         (remove-all-midi-cc-fns) ;; clear all connections
         (add-midi-cc-fn
          (lambda (ccval) (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 1" ccval))
          1 1)  
         (add-midi-cc-fn
          (lambda (ccval) (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 2" ccval))
          1 2)  
         (add-midi-cc-fn
          (lambda (ccval) (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 3" ccval))
          1 3))
                
       ;; => init-connections

       ;; using *midi-cc-state*

       (defun init-connections ()
         (mapc #'funcall *unwatch*) ;; clear all connections
         (setf *unwatch* nil)
         (watch
          (lambda (ccval) (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 1" ccval)))  
         (add-midi-cc-fn
          (lambda (ccval) (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 2" ccval))
          1 2)  
         (add-midi-cc-fn
          (lambda (ccval) (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 3" ccval))
          1 3))

       ;; => init-connections
     #+END_SRC
     In both cases, calling #'init-connections will first remove all
     existing connections and then set them up. Whenever a new
     connection is made, it can be added to the init-connections
     function. After compiling the function and calling it, all
     connections are set up.
**** Example using Incudine responders
     It is not required to rely on the infrastructure of Clamps to
     react to Midi input events. Incudine provides all necessary tools
     to set up your own MIDI input handlers, giving you even more
     flexibility[fn:2].

     Reacting to MIDI input is done by defining
     /responders/. Responders are functions called whenever MIDI input
     is received. The function /make-responder/ takes the MIDI input
     stream and a function to be called whenever MIDI input is
     received on the stream and returns a MIDI responder.

     The function supplied to /make-responder/ takes three arguments:
     The /status/ byte, the /data1/ byte and the /data2/ byte. Each of
     these arguments takes an integer number in the range [0..127],
     the usual range for MIDI messages. The /status/ byte contains the
     /type/ of the MIDI message and the /channel number/. The
     information of the /data1/ and /data2/ parameters depends on the
     message type. In the case of MIDI CC messages, /data1/ is the /CC
     number/ and /data2/ the /CC value/. In case of note-on or
     note-off messages, /data1/ represents the /keynum/ and /data2/
     the /velocity/.

     As the status byte is not straightforward to decode, CM provides
     utility functions called status->channel and status->opcode to
     extract the channel and opcode information from the status
     byte. status->opcode returns ist results as a keyword. /:cc/ for
     CC messages and /:note-on/ or /:note-off/ for note
     messages[fn:3].

     /recv-start/ and /recv-stop/ are functions of Incudine which
     start or suspend receiving MIDI messages on a particular MIDI
     input stream aupplied as argument to these functions. Both
     functions can get called at any time and will also work in the
     two first examples[fn:4].
     #+BEGIN_SRC lisp
       ;; suspend receiving midi events

       (incudine:recv-stop *midi-in1*)

       ;; => #<RECEIVER jackmidi:input-stream stopped>

       ;; (re)start receiving midi events

       (recv-start *midi-in1*)

       ;; => #<RECEIVER jackmidi:input-stream running>

     #+END_SRC

     
     Below is an example how to achieve the behaviour of the first two
     examples. 
     
     #+BEGIN_SRC lisp
       ;; define a variable to store all responders:

       (defvar *my-midi-responder* nil) ; => *my-midi-responder*

       (setf *my-midi-responder*
        (make-responder
         ,*midi-in1*
         (lambda (st d1 d2)
           (let ((channel (status->channel st))
                 (opcode (status->opcode st)))
             (case channel
               (1 (case opcode
                    (:cc (let ((ccnum d1)
                               (cc-val d2))
                           (case ccnum
                             (1 (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 1"
                                      cc-val))
                             (2 (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 2"
                                      cc-val))
                             (3 (msg :warn "Received CC Value ~a on Midi Channel 1 and CC Number 3"
                                      cc-val))))))))))))

       ;;  => #S(#:responder
       ;; :receiver #<RECEIVER jackmidi:input-stream running>
       ;; :function #<function (lambda
       ;;                          (incudine::status incudine::data1 incudine::data2
       ;;                           stream)
       ;;                        :in
       ;;                        incudine::midi-responder-wrapper) {10025E7C0B}>)



       ;; removing the responder

       (remove-responder *my-midi-responder*) ; => ; No value

       ;; If the message is always the same, the function can be simplified

       (setf *my-midi-responder*
         (make-responder
          ,*midi-in1*
          (lambda (st d1 d2)
            (let ((channel (status->channel st))
                  (opcode (status->opcode st)))
              (case opcode
                (:cc (let ((cc-num d1)
                           (cc-val d2))
                       (msg :warn "Received CC Value ~a on Midi Channel ~a and CC Number ~a"
                             cc-val channel cc-num))))))))

       ;; => #S(#:responder
       ;;   :receiver #<RECEIVER jackmidi:input-stream running>
       ;;   :function #<function (lambda
       ;;                            (incudine::status incudine::data1 incudine::data2
       ;;                             stream)
       ;;                          :in
       ;;                          incudine::midi-responder-wrapper) {1002D4D76B}>)


       ;; remove the midi responder

       (remove-responder *my-midi-responder*) ; => ; No value

     #+END_SRC
     All these methods have their advantages and disadvantages. The
     last example combines all MIDI input handling in one function
     which is compact and nice if there aren't too many responders to
     be used, but can become bloated if responding to many different
     messages. On the other hand, there is no need to just define one
     responder in Incudine. Different functionality can be distributed
     to different responders.

**** Exercise

     Pure Data provides Midi responders for all common message types,
     called /notein/, /ctlin/, /bendin/, etc. It outputs 3 or 2
     values, depending on the message type.

     Write a wrapper around Incudine's /make-responder/, called
     /notein/, /ctlin/ and /bendin/, which uses *​midi-in1​* as
     input. Each of these functions accepts only a function as
     argument and returns the responder. Depending on the implemented
     MIDI type, this function will have either 3 or 2 arguments, equal
     to the number of outlets of the corresponding Pure Data objects.

     Give an example for each of the functions which will print out
     the received midi input in the following formats:

     /"midi notein: <keynum> <velocity> <channel>"/

     /"midi ctlin: <cc-val> <cc-num> <channel>"/

     /"midi bendin: <bendvalue> <channel>"/

*** MIDI Controllers
    cl-midictl implements an object oriented infrastructure to support
    dealing with hardware MIDI controllers. Its base class is
    [[dict:midi-controller][midi-controller]]. Currently classes for the [[https://www.korg.com/de/products/computergear/nanokontrol2/][Korg NanoKONTROL2]] and
    the [[https://faderfox.de/ec4.html][Faderfox EC4]] are implemented.

**** Using a Korg NanoKONTROL2 Controller
***** Preparation
      Restore the NanoKontrol2 to the factory defaults and set the
      /LED Mode/ in the /Common/ section of the [[https://www.korg.com/us/support/download/software/0/159/1354/][Korg Kontrol Editor]]
      application to "External".

***** Initialization
      To initialize the controller, issue the [[dict:add-midi-controller][add-midi-controller]]
      method with the nanoktl2-midi class and a custom ID and
      optionally its channel as arguments:
     
      #+BEGIN_SRC lisp
        ;; create an instance of a NanoKONTROL2 midi-controller with ID :nk2
        ;; using MIDI channel 1 and add it to the registry:

        (add-midi-controller 'nanoktl2-midi :nk2 :chan 1)
      #+END_SRC

      If the NanoKONTROL2 hardware device is connected to the incudine
      in/output ports, it now can be used. For details about the slots
      and their layout, refer to [[dict:nanoktl2-midi][nanoktl2-midi]] in the Clamps
      Dictionary.

***** Adding Behaviour
      We can add behaviour to the instance by attaching [[dict:watch][watch]]
      functions to the faders and knobs or [[dict:trigger][trigger]] functions to the
      buttons:
****** Faders and Knobs
       #+NAME: nanoktl2-example
       #+BEGIN_SRC lisp
         (with-slots (unwatch nk2-faders) (find-controller :nk2)
           (dotimes (i 8)
             (let ((n i))
               (push (watch
                      (lambda () (msg :warn (format nil "Knob ~a turned: ~a" (1+ n)
                                                (get-val (aref nk2-faders n))))))
                     unwatch)
               (push (watch
                      (lambda () (msg :warn (format nil "Fader ~a moved: ~a" (1+ n)
                                               (get-val (aref nk2-faders (+ n 8)))))))
                     unwatch))))
         ;; => nil
         ;;
         ;; output in the REPL:
         ;; warn: Knob 1 turned: 0
         ;; warn: Fader 1 moved: 0
         ;; warn: Knob 2 turned: 0
         ;; warn: Fader 2 moved: 0
         ;; warn: Knob 3 turned: 0
         ;; warn: Fader 3 moved: 0
         ;; warn: Knob 4 turned: 0
         ;; warn: Fader 4 moved: 0
         ;; warn: Knob 5 turned: 0
         ;; warn: Fader 5 moved: 0
         ;; warn: Knob 6 turned: 0
         ;; warn: Fader 6 moved: 0
         ;; warn: Knob 7 turned: 0
         ;; warn: Fader 7 moved: 0
         ;; warn: Knob 8 turned: 0
         ;; warn: Fader 8 moved: 0
       #+END_SRC

       The output in the REPL signals that the watch function has been
       established for all knobs and faders.

       Moving a fader works like expected:
       #+BEGIN_SRC lisp
        clamps> 
        warn: Fader 1 moved: 1.0
        warn: Fader 1 moved: 2.0
        warn: Fader 1 moved: 3.0
        warn: Fader 1 moved: 4.0
        warn: Fader 1 moved: 5.0
        warn: Fader 1 moved: 6.0
        warn: Fader 1 moved: 7.0
        warn: Fader 1 moved: 8.0
        warn: Fader 1 moved: 9.0
        <...>
        clamps> 
       #+END_SRC

       #+HTML: <h5>Important Note</h5>
       #+LATEX: Important Note

       In the above [[nanoktl2-example][Fader/Knob example]], it might not be obvious that
       the binding of /n/ to /i/ using the /let/ in the body of the
       /dotimes/ is crucial for this to work. If it isn't clear, why
       it wouldn't work to use /i/ directly in the /lambda/ forms of
       the /watch/ expressions, refer to the section [[Excursion:
       Closures]]. The section tries to shed some light on binding and
       the difference of /compile-time/ vs. /run-time/. Knowing how to
       deal with closures is a recurring necessity when working with
       Clamps and a thorough understanding indispensible.

****** Buttons
       A button is inspired by a Gui element of a button, adding click
       events on the button. It is implemented in [[cl-refs]] as a
       [[dict:bang-object][bang-object]], a ref-cell with an additional [[dict:trigger][trigger]] function,
       which ist invoked on a button press/click.

       To add an action to the button, use the function
       [[dict:add-trigger-fn][add-trigger-fn]].

       Here is an example:

       #+BEGIN_SRC lisp
         (add-trigger-fn (tr-play (find-controller :nk2)) (lambda () (msg :warn "tr-play Button pressed.")))
         ;; => nil
       #+END_SRC

       #+BEGIN_SRC lisp
         (trigger (tr-play (find-object :nk2)))
         ;; output in the REPL:
         ;; warn: tr-play Button pressed.
       #+END_SRC
 
       This behaviour is automatically implemented in the
       [[dict:handle-midi-in][handle-midi-in]] method of a nanoktl2-midi instance: When
       pressing the tr-play button on the NanoKONTROL2 Hardware
       Controller, it will call the [[dict:trigger][trigger]] function on the tr-play
       slot of the instance and you should see the same message in the
       REPL as before:
       #+BEGIN_SRC lisp
         clamps> 
         warn: tr-play Button pressed.
         clamps> 
       #+END_SRC

       The same result is achievd by calling [[dict:trigger][trigger]] with the
       bang-object as argument:      

      Removing the trigger functions from the button can be done using
      the function [[dict:remove-all-triggers][remove-all-triggers]]:

       #+BEGIN_SRC lisp
         (remove-all-triggers (tr-play (find-controller :nk2)))
       #+END_SRC

       Like [[dict:watch][watch]], [[dict:add-trigger-fn][add-trigger-fn]] returns a function to remove the
       trigger function(s) from the ref-cell. Therefore you can also
       implement adding the trigger function to the nanoktl2-midi
       instance like this to be able to have a finer control over
       selectively adding and removing trigger functions for
       ref-cells:
      
       #+BEGIN_SRC lisp
         (defvar *unwatch-triggers* nil)
         (push (add-trigger-fn (tr-play (find-controller :nk2)) (lambda () (msg :warn "tr-play Button pressed.")))
               ,*unwatch-triggers*)
         ;;  => (#<function (lambda () :in add-trigger-fn) {100A94123B}>

         ;; remove the trigger function:

         (progn
           (map nil #'funcall *unwatch-triggers*)
           (setf *unwatch-triggers* nil))
         ; => nil

         ;; abbreviation of the above expression:

         (setf *unwatch-triggers*
               (map nil #'funcall *unwatch-triggers*))
         ; => nil
       #+END_SRC

       #+HTML: <h5>Note</h5>
       #+LATEX: Note
       As buttons are extended ref-cells, they also have a value slot
       which can be accessed and manipulated like any normal
       ref-cell. An application can be use this to capture the state
       of the button (on, off, flashing, etc.) in relation to, but
       independent from the button-press (trigger) action.
**** Other Utility Functions
     To get a registered intance of a midi controller, use the
     [[dict:find-midi-controller][find-controller]] function with its ID as argument.
     #+BEGIN_SRC lisp
       (find-controller :nk2) ; => #<nanoktl2-midi {100438D503}>
     #+END_SRC

     [[dict:remove-midi-controller][remove-midi-controller]] removes a midi controller. This also calls
     all functions in the list stored in the /unwatch/ slot of the
     midi-controller.

     To remove all midi controllers, use
     [[dict:remove-all-midi-controllers][remove-all-midi-controllers]]:

     #+BEGIN_SRC lisp
       (remove-midi-controller :nk2) ;; => t

       (remove-all-midi-controllers) ;; => nil
     #+END_SRC

     [[dict:list-midi-controllers][list-midi-controllers]] will list the id of all registered midi
     controllers.
     #+BEGIN_SRC lisp
       (add-midi-controller 'nanoktl2-midi :nk2 :chan 1)
       ;; => #<nanoktl2-midi {1007370403}>
       ;;
       ;; output in the REPL:
       ;; adding midi controller :nk2

       (list-midi-controllers)
       ;; => (:nk2)

       (remove-all-midi-controllers) 
       ;;  => nil
       ;;
       ;; output in the REPL:
       ;; removing midi controller :nk2 (t)

     #+END_SRC

     
**** Excursion: Closures
     The definition of the watch functions in the [[nanoktl2-example][NanoKONTROL2 example]]
     contains a tricky part: The variable /i/ of the /dolist/ is bound
     to a symbol /n/ in each iteration using a /let/ expression in its
     body.

     This is necessary: If the /let/ form is omitted and the variable
     /i/ directly referenced in all 16 watched functions, it wouldn't
     work as expected: /i/ would be dereferenced at the moment, when
     the lambda function gets /called/ as an effect of moving a fader
     and not at the moment, the lambda form got /defined/ in the
     context of the call to the watch function during the evaluation
     of the dolist.

     After the dolist has finished, the value of /i/ is 8 and that
     will be the value seen in any of the functions defined by
     /watch/.  All functions dereference the same /i/ when a fader is
     moved.

     Let's see this in action:
    #+BEGIN_SRC lisp
      ;; WARNING: Faulty implementation of binding watch functions in an
      ;; iteration:

      (with-slots (unwatch nk2-faders) (find-controller :nk2)
        (dotimes (i 8)
          (push (watch
                 (lambda () (msg :warn (format nil "Knob ~a turned: ~a" (1+ i)
                                           (get-val (aref nk2-faders i))))))
                unwatch)
          (push (watch
                 (lambda () (msg :warn (format nil "Fader ~a moved: ~a" (1+ i)
                                           (get-val (aref nk2-faders (+ i 8)))))))
                unwatch)))
      ;; => nil
      ;; Output in the REPL:
      ;; warn: Knob 1 turned: 0
      ;; warn: Fader 1 moved: 0
      ;; warn: Knob 2 turned: 0
      ;; warn: Fader 2 moved: 0
      ;; warn: Knob 3 turned: 0
      ;; warn: Fader 3 moved: 0
      ;; warn: Knob 4 turned: 0
      ;; warn: Fader 4 moved: 0
      ;; warn: Knob 5 turned: 0
      ;; warn: Fader 5 moved: 0
      ;; warn: Knob 6 turned: 0
      ;; warn: Fader 6 moved: 0
      ;; warn: Knob 7 turned: 0
      ;; warn: Fader 7 moved: 0
      ;; warn: Knob 8 turned: 0
      ;; warn: Fader 8 moved: 0

    #+END_SRC
    When initializing the watch functions everything seems to work: On
    definition of the watch in the dolist iteration, the lambda
    function gets called once. This moment is called /compile-time/
    and at that moment, /i/ has the correct value as can be seen in
    the REPL output above.

    But after the /dotimes/ has finished, the variable /i/ is bound to
    the value 8, which becomes evident when moving any fader at
    /run-time/:
    #+BEGIN_SRC lisp
      ;; Output in the REPL when moving a fader:

      clamps>
      error: Invalid index 16 for (vector t 16), should be a non-negative integer below 16.
      error: Invalid index 16 for (vector t 16), should be a non-negative integer below 16.
      error: Invalid index 16 for (vector t 16), should be a non-negative integer below 16.
      error: Invalid index 16 for (vector t 16), should be a non-negative integer below 16.
      error: Invalid index 16 for (vector t 16), should be a non-negative integer below 16.
      clamps>

    #+END_SRC

    The error occurs only, when a fader is moved, because their lambda
    functions use the index (+ 8 i) which is 16 in this faulty
    implementation and beyond the maximum index 15 of the fader array
    in the Nanoktl2 instance. When moving a knob, the output in the
    REPL will state that knob 9 has been turned (which doesn't exist)
    and the value reported will be the last value received from Fader
    1 because that is the Fader at index 8 of the array[fn:5]:

    #+BEGIN_SRC lisp
      ;; Output in the REPL when turning a knob:

      clamps>
      ;; warn: Knob 9 turned: 0.0
      ;; warn: Knob 9 turned: 0.0
      ;; warn: Knob 9 turned: 0.0
      ;; warn: Knob 9 turned: 0.0
      ;; warn: Knob 9 turned: 0.0
      clamps>
    #+END_SRC

    To avoid this situation, the /let/ expression in the [[nanoktl2-example][correct
    example]] serves the purpose of using a new variable /n/ in each
    iteration of the dolist to capture the value of /i/ at the
    /compile-time/ of the function so that dereferencing /n/ at
    /run-time/ will refer to the correct value.
    
    Capturing variable bindings of functions at compile-time for
    correct dereferencing at run-time uses so-called [[https://en.wikipedia.org/wiki/Closure_(computer_programming)][closures]]. It is
    very important to have a good understanding of this concept when
    working with clamps (or any dynamic system with functional
    properties).

    Without going into too much detail, following are some examples
    intended to clarify what is happening above. It is important to
    study the examples thoroughly until it is completely understood
    what is happening.
    #+BEGIN_SRC lisp
      (defparameter *my-fn* nil)
      ;; => *my-fn*

      ;; example of a closure: The symbol i is bound outside of the function
      ;; body and the function dereferences its value, whenever it gets
      ;; called:

      (let ((i 3))
        (setf *my-fn*
              (lambda () i)))
      ;; => #<function (lambda ())

      (funcall *my-fn*) ; => 3

      ;; This is the same in the context of an iteration: The symbol i is
      ;; incremented on each iteration of the dotimes until it reaches the
      ;; value 8, which stops the iteration. In other words: After the
      ;; iteration has ended, i has the value 8. As the function
      ;; dereferences the value of i at the time the function gets called,
      ;; it returns the value 8:

      (dotimes (i 8)
        (setf *my-fn* (lambda () i)))
      ;; => nil

      (funcall *my-fn*) ; => 8

      ;; The same again but showing, that i is never reaching the value 8
      ;; within the iteration:

      (dotimes (i 8)
        (print i)
        (setf *my-fn* (lambda () i)))
      ;; => nil
      ;; output in the REPL:
      ;; 0 
      ;; 1 
      ;; 2 
      ;; 3 
      ;; 4 
      ;; 5 
      ;; 6 
      ;; 7 

      ;; As before, when calling *my-fn* it will return the value of i after
      ;; the iteration has finished:

      (funcall *my-fn*) ; => 8

      ;; Binding the symbol n to the value of i within the dotimes will
      ;; dereference the values of i during the loop:

      (dotimes (i 8)
        (let ((n i))
          (setf *my-fn* (lambda () n))))
      ;; => nil

      ;; The let binds a new n with the current value of the outer i in each
      ;; iteration. When the iteration is done, *my-fn* has been
      ;; rebound/redefined 8 times to reference the new inner n
      ;; symbols. After the loop has finished, *my-fn* returns the value of
      ;; the last binding of n in the last loop iteration.
      ;;
      ;; In that iteration i had the value 7 and n was bound to that value,
      ;; so when n gets dereferenced later, it will evaluate to 7:

      (funcall *my-fn*) ; => 7

      ;; For clarity: The let creates a new and different n on-the-fly on
      ;; each iteration. This might get clearer when spelling out the
      ;; 8 iterations of the dotimes:

      (block nil
        (let ((i 0))                       ;; start of the dotimes: i is 0
          (let ((n i))                     ;; a new n is bound to 0
            (setf *my-fn* (lambda () n)))
          (incf i)                         ;; i is 1
          (if (= i 8) (return))
          (let ((n i))                     ;; a new n is bound to 1
            (setf *my-fn* (lambda () n)))
          (incf i)                         ;; i is 2
          (if (= i 8) (return))
          (let ((n i))                     ;; a new n is bound to 2
            (setf *my-fn* (lambda () n)))
          (incf i)                         ;; i is 3
          (if (= i 8) (return))
          (let ((n i))                     ;; a new n is bound to 3
            (setf *my-fn* (lambda () n)))
          (incf i)                         ;; i is 4
          (if (= i 8) (return))
          (let ((n i))                     ;; a new n is bound to 4
            (setf *my-fn* (lambda () n)))
          (incf i)                         ;; i is 5
          (if (= i 8) (return))
          (let ((n i))                     ;; a new n is bound to 5
            (setf *my-fn* (lambda () n)))
          (incf i)                         ;; i is 6
          (if (= i 8) (return))
          (let ((n i))                     ;; a new n is bound to 6
            (setf *my-fn* (lambda () n)))
          (incf i)                         ;; i is 7
          (if (= i 8) (return))
          (let ((n i))                     ;; a new n is bound to 7
            (setf *my-fn* (lambda () n)))  ;; last definition of *my-fn* which will get used
          (incf i)                         ;; i is 8
          (if (= i 8) (return))))          ;; end of the dotimes
      ;; => nil

      (funcall *my-fn*) ; => 7
    #+END_SRC

    In the [[nanoktl2-example][correct example]], two new watch function bindings are
    established in each of the 8 iterations. As in the example above,
    the /let/ binds a new /symbol/ n to the current /value/ of the
    outer iteration variable i.

    It is crucial to understand, that n is not bound to the /symbol/
    i, but to its /value/ because the /let/ evaluates i, before
    binding n to it.

    Also it is crucial to understand that the different symbols /n/ in
    the /let/ forms above are actually different and are only valid
    and accessible within the body of the /let/ in which they are
    bound (which is the main idea of /let/ in the first place).

    Last not least it should be mentioned that it is not uncommon, to
    use the same symbol for the outer iteration and the inner let like
    this:

    #+BEGIN_SRC lisp
      ;; using an array of 8 functions for clarity:

      (defparameter *my-fns* #(nil nil nil nil nil nil nil nil))
      ;; => *my-fns*

      (dotimes (n 8)
        (let ((n n))
          (setf (aref *my-fns* n) (lambda () n))))
      ;; => nil

      (funcall (aref *my-fns* 0)) ; => 0
      (funcall (aref *my-fns* 1)) ; => 1
      (funcall (aref *my-fns* 4)) ; => 4
      (funcall (aref *my-fns* 7)) ; => 7
    #+END_SRC
    This is exactly the same as before: In the let, a new symbol /n/
    gets bound to the /value/ of the outer symbol n in every
    iteration. In the lexical scope (the body) of the let, the new
    binding of n takes precedence over the outer n, so referencing n
    in the /aref/ and in the /lambda/ expression will dereference the
    new binding established in the /let/. This is called /shadowing/,
    or, in other words, the inner n /"shadows"/ the outer n.

    Closures are such a powerful construct that they have become
    increasingly common in many programming languages and many books
    have been dedicated to their exploration[fn:6]. But as in real
    life: With power comes responsibility and it should be mentioned
    that this power can come at the price of an overwhelming
    complexity, so it should be handled with care.
    
# *** Debugging MIDI IO
** clog-midi-controller
   clog-midi-controller defines the GUI parts of midi controllers
   defined in the framework of [[cl-midictl]]. To understand how they work
   it is necessary to study how Gui programming in Clamps works in
   general using [[clog-dsp-widgets]].
* CM Extensions
** General
   Common Music's infrastructure uses the [[dict:events][events]] method to output
   events[fn:7]. events is a [[https://en.wikipedia.org/wiki/Multiple_dispatch][multiple dispatch]] method, dispatching
   different event classes to different output backends. The first
   argument of events is an instance of an event class, the second
   argument is either an instance of class /<incudine-stream>/
   indicating realtime output, or a string denoting a filename. The
   filename extension is used for the dispatch of the output backend.

   The event classes defined by CM 2.12 for output are[fn:8]:

   - MIDI events of all types
   - OSC events for SuperCollider
   - CLM events for CLM

   The supported output types in CM 2.12 and their class/filename
   extensions are:

   #+ATTR_HTML: :style text-align: left;
   |--------------------+-----------------------------|
   | Output type        | Class or Filename extension |
   |--------------------+-----------------------------|
   | [[dict:rts][Realtime]]           | /<incudine-stream>/         |
   | [[dict:midi-file][MIDI file]]          | /".midi"/, /".mid"/         |
   | [[dict:sc-file][SuperCollider file]] | /".osc"/                    |
   | [[dict:cmn-file][SCO file]]           | /".sco"/                    |
   | [[dict:cmn-file][CMN file]]           | /".cmn"/                    |
   | [[dict:cmn-file][CLM file]]           | /".clm"/                    |
   | Soundfile          | /".aiff"/, /".wav"/         |
   | [[dict:cmn-file][EPS file]]           | /".eps"/                    |
   | [[dict:fomus-file][FOMUS file]]         | /".ly"/, /".xml"/, /".dat"/ |


   The SCO file format in Common Music seems to have been only
   partially implemented.

   Below is an overview of the implemented output methods for the
   different event types and output backends in Common Music:

   #+ATTR_HTML: :border 1px :rules all :frame border :style text-align: center; cell-padding: 1em; border-spacing: 1em;
   |------+-----------+---------+----------+----------+------------+-----------+----------+----------|
   |      | MIDI file | SC file | CMN file | EPS file | FOMUS file | Soundfile | CLM file | Realtime |
   |------+-----------+---------+----------+----------+------------+-----------+----------+----------|
   | MIDI | x         |         | x        |          | x          |           |          | x        |
   | OSC  |           | x       |          |          |            |           |          | x        |
   | CMN  | x         |         | x        | x        |            |           |          |          |
   | CLM  |           | x       |          |          |            | x         | x        |          |
   |------+-----------+---------+----------+----------+------------+-----------+----------+----------|
   
   The CMN type and output file types (".cmn" and ".eps") and the CLM
   types are currently not actively supported in Clamps, as CMN is
   replaced in favor of FOMUS and CLM is emulated in cuda-clm and its
   functionality provided by Incudine. Both systems should
   nevertheless continue to work to the extent they worked in CM 2.12.

   Clamps extends the event classes of CM by the following event
   classes:
   
   - [[dict:sfz][sfz]] (see [[cm-sfz]])
   - [[dict:poolevt][poolevt]] (see [[cm-poolevt]])
   - [[FUDI][cm-fudi]]

   In addition Clamps extends the available output backends of Common
   Music by a [[cm-svg][SVG]] backend, using the filename extension /".svg"/.

   The realtime backend in Clamps uses the special variable
   [[dict:#rts-out][*​rts-out​*]]. Its value is an /<incudine-stream>/. When a MIDI event
   is sent to this stream, clamps automatically dispatches it to the
   midi-output of ~*​rts-out​*~ (by default this is ~*​midi-out1​*~). If
   instead the output is realized using incudine dsps, as in the case
   of [[dict:sfz][sfz]] output, the dsps are automatically scheduled and
   instantiated.
   
   Below is an overview of the implemented output methods for the
   different event types and output backends in Clamps:
   
   #+ATTR_HTML: :border 1px :rules all :frame border :style text-align: center; cell-padding: 1em; border-spacing: 1em;
   |---------+-----------+---------+------------+----------+----------|
   |         | MIDI file | SC file | FOMUS file | SVG file | Realtime |
   |---------+-----------+---------+------------+----------+----------|
   | MIDI    | x         |         | x          | x        | x        |
   | OSC     |           | x       |            | x        | x        |
   | SFZ     |           |         | x          | x        | x        |
   | Poolevt |           |         |            | x        | x        |
   | FUDI    |           |         |            |          | x        |
   |---------+-----------+---------+------------+----------+----------|

** cm-incudine
   cm-incudine a compatibility layer between Common Music and
   incudine, mainly concerning realtime input and output. The
   /<incudine-stream>/ class is defined here, input/output to
   jackmidi, the FUDI event class[fn:9], etc.

   The user normally doesn't need to deal with cm-incudine directly.
   Starting and stopping MIDI and initializing incudine streams is
   done with highlevel functions from clamps, explained in their
   respective chapters (see [[Opening MIDI Ports]] or [[#clamps-startup][Startup]].
# ** cm-all
** cm-fomus
   cm-fomus is a [[https://fomus.common-lisp.dev/][FOMUS]] backend for Common Music written by Rick Taube
   and is included in Clamps for convenience. Clamps mainly supports
   the LilyPond backend of FOMUS.

   For an explanation of the implementation details see the [[../fomus/index.html][fomus]]
   documentation included on this website, which contains a part on
   Common Music. In addition there are examples in the Common Music
   distribution at
   /~/quicklisp/cm/doc/404B-SoundSynth-AlgoComp/www-camil.music.uiuc.edu_16080/classes/404B/fomus/examples.lisp/.
** cm-sfz
   cm-sfz extends [[cl-sfz]] by implemenings the [[dict:sfz][sfz]] class for Common
   Music, derived from its /event/ class. Like any other event class
   in CM an instance is created with the [[dict:new][new]] macro.
   #+BEGIN_SRC lisp
     (new sfz)
     ;; => #i(sfz keynum 60 amplitude 1 duration 1
     ;;           preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100
   #+END_SRC
   Playback of a sfz instance can be achieved with the usual methods
   of Common Music:
   #+BEGIN_SRC lisp
     (output (new sfz))
     ;; => ; No value

     (sprout (new sfz :time 0))
     ;; => nil

     (events (new sfz :time 0) *rts-out*)
     ;; => #<incudine-stream "midi-out1">
   #+END_SRC
   Apart from realtime output, backends for /LilyPond/ (see [[cm-fomus]])
   and /SVG/ output (see [[cm-svg]]) are defined:
   #+BEGIN_SRC lisp
     (events
      (loop
        repeat 10
        for time from 0 by 0.1
        collect (new sfz :time time :keynum (between 60.0 83.0)
                  :duration 0.1))
      "/tmp/test.svg")
     ;; => "/tmp/test.svg"
   #+END_SRC
   Note that there are no limitations concerning microtonal output for
   SVG files and for realtime playback. For lilypond output, the
   keynums are rounded to the closest quartertone, if the
   /:quartertones/ option of FOMUS is set:
   #+BEGIN_SRC lisp
     (events
           (loop
             repeat 8
             for time from 0 by 0.125
             collect (new sfz :time time :keynum (between 60.0 83.0)
                       :duration 0.125))
           "/tmp/test.ly"
           :quartertones t)
   #+END_SRC
** cm-svg
   The SVG in/output backend for Common Music is a central part of the
   Clamps architecture. Its main objective is to provide a single
   unified output format for any type of timed event in combination
   with a graphical representation of the data.

   Once exported, the graphical representation can be inspected or
   edited using any graphical editor for SVG files and reimported into
   clamps. An extension for the Inkscape Editor is included in Clamps
   for playback of selected objects directly from Inkscape.
*** Export to SVG
    Exporting to SVG is done with the [[dict:events][events]] function. As different
    event types are supported by Clamps, any combination of MIDI, SFZ,
    Poolevt or custom declared event types can be integrated into a
    single sequence and exported to SVG with a single call to
    [[dict:events][events]].

    The exported SVG elements are displayed in a 2-dimensional grid
    with the x-axis denoting musical time, although any other mapping
    can easily be applied to the im/exported data if deemed
    appropriate. The exported graphical objects can be considered as
    /typed/ output[fn:10], with their type and additional custom
    properties defined in an /attributes/ tag of each SVG element (see
    [[fig:svg-xml-example]]).

#+HTML: <h4>Example</h4>
   #+BEGIN_SRC lisp
     (events
       (append
        (loop
          for time below 3 by 2/8
          collect (new sfz :time time :keynum (between 60.0 84.0) :duration 1/2))
        (loop
          for time from 1/8 below 3 by 2/8
          collect (new midi :time time :keynum (between 60 84)
                    :amplitude 1.0 :channel (between 1 16) :duration 1/2)))
      (svg-gui-path "svg-xml-example.svg")
      :showgrid nil
      :staff-system-vis nil)
   #+END_SRC

    #+attr_html: :width 50%
    #+CAPTION: Attributes of a selected event in SVG file generated with the Lisp Code above
    #+NAME:   fig:svg-xml-example
    [[./img/svg-xml-example.png]]  
*** Import from SVG
    Importing objects from SVG are done using Common Musics
    [[dict:import-events][import-events]] function with the filename as argument.

    Like for export, objects of any supported type can be imported and
    will be included in the same sequence object. below is an example
    for importing into Clamps using the exported svg file from the
    previous section.

    #+attr_html: :width 50%
    #+CAPTION: Example of a SVG file with mixed event types to import
    #+NAME:   fig:svg-import-example
    [[./img/svg-xml-example.svg]]  
    
    #+BEGIN_SRC lisp
      (sort
       (subobjects
        (import-events (svg-gui-path "svg-xml-example.svg")))
       #'< :key #'object-time)
      ;; => (#i(sfz time 0.0 keynum 63.42938 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 0.125 keynum 63.0 duration 0.5 amplitude 0.5 channel 1)
      ;;     #i(sfz time 0.25 keynum 80.86092 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 0.375 keynum 79.0 duration 0.5 amplitude 0.5 channel 9)
      ;;     #i(sfz time 0.5 keynum 61.039192 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 0.625 keynum 61.0 duration 0.5 amplitude 0.5 channel 9)
      ;;     #i(sfz time 0.75 keynum 68.02148 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 0.875 keynum 64.0 duration 0.5 amplitude 0.5 channel 10)
      ;;     #i(sfz time 1.0 keynum 64.643036 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 1.125 keynum 82.0 duration 0.5 amplitude 0.5 channel 9)
      ;;     #i(sfz time 1.25 keynum 73.90509 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 1.375 keynum 77.0 duration 0.5 amplitude 0.5 channel 7)
      ;;     #i(sfz time 1.5 keynum 75.27113 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 1.625 keynum 60.0 duration 0.5 amplitude 0.5 channel 3)
      ;;     #i(sfz time 1.75 keynum 63.145172 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 1.875 keynum 79.0 duration 0.5 amplitude 0.5 channel 38)
      ;;     #i(sfz time 2.0 keynum 69.082825 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 2.125 keynum 65.0 duration 0.5 amplitude 0.5 channel 1)
      ;;     #i(sfz time 2.25 keynum 71.13065 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 2.375 keynum 67.0 duration 0.5 amplitude 0.5 channel 2)
      ;;     #i(sfz time 2.5 keynum 70.6771 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 2.625 keynum 80.0 duration 0.5 amplitude 0.5 channel 6)
      ;;     #i(sfz time 2.75 keynum 69.82674 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(midi time 2.875 keynum 62.0 duration 0.5 amplitude 0.5 channel 24))
    #+END_SRC
    Any of Common Music's filtering options defined for [[dict:map-objects][map-objects]] can be applied:
    #+BEGIN_SRC lisp
      (subobjects
       (import-events (svg-gui-path "svg-xml-example.svg"))
       :class 'sfz)
      ;; => (#i(sfz time 0.0 keynum 63.42938 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 0.25 keynum 80.86092 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 0.5 keynum 61.039192 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 0.75 keynum 68.02148 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 1.0 keynum 64.643036 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 1.25 keynum 73.90509 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 1.5 keynum 75.27113 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 1.75 keynum 63.145172 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 2.0 keynum 69.082825 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 2.25 keynum 71.13065 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 2.5 keynum 70.6771 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100)
      ;;     #i(sfz time 2.75 keynum 69.82674 amplitude 0.0 duration 0.5 preset :flute-nv oneshot nil pan 0.5 startpos 0 chan 100))

      (subobjects
       (import-events (svg-gui-path "svg-xml-example.svg"))
       :class 'midi)
      ;; => (#i(midi time 1.625 keynum 60.0 duration 0.5 amplitude 0.5 channel 3)
      ;;     #i(midi time 0.125 keynum 63.0 duration 0.5 amplitude 0.5 channel 1)
      ;;     #i(midi time 0.875 keynum 64.0 duration 0.5 amplitude 0.5 channel 10)
      ;;     #i(midi time 0.375 keynum 79.0 duration 0.5 amplitude 0.5 channel 9)
      ;;     #i(midi time 0.625 keynum 61.0 duration 0.5 amplitude 0.5 channel 9)
      ;;     #i(midi time 1.125 keynum 82.0 duration 0.5 amplitude 0.5 channel 9)
      ;;     #i(midi time 2.375 keynum 67.0 duration 0.5 amplitude 0.5 channel 2)
      ;;     #i(midi time 1.375 keynum 77.0 duration 0.5 amplitude 0.5 channel 7)
      ;;     #i(midi time 2.625 keynum 80.0 duration 0.5 amplitude 0.5 channel 6)
      ;;     #i(midi time 1.875 keynum 79.0 duration 0.5 amplitude 0.5 channel 38)
      ;;     #i(midi time 2.875 keynum 62.0 duration 0.5 amplitude 0.5 channel 24)
      ;;     #i(midi time 2.125 keynum 65.0 duration 0.5 amplitude 0.5 channel 1))

      #+END_SRC

    
*** Inkscape Playback
    When the /Play Selection/ extension of Inkscape is installed,
    selected objects in an Inkscape document can be played back
    directly from Inkscape, after Clamps has been started.

    Simply select the objects to play back and issue /Play Selection/
    from the extensions menu. The selected objects will get saved as
    lisp code into the file /"/tmp/incudine-export.lisp"/ and an OSC
    message is sent to the clamps process triggering loading of the
    file which will result in its immediate playback.

    #+attr_html: :width 100%
    #+CAPTION: Using the Inkscape Play Selection extension
    #+NAME:   fig:play-selection
    [[./img/play-selection.png]]  
** cm-svg.rts
   cm-svg.rts implements a SVG file player using the Gui interface of
   Clamps. To load a SVG file into it, put the svg file to load into
   the svg subfolder of [[dict:clamps-gui-root][clamps-gui-root]] and call the function
   [[dict:svg->browser][svg->browser]] with the filename as argument:
   #+BEGIN_SRC lisp
     (svg->browser "svg-xml-example.svg")
   #+END_SRC
   When the browser is opened with the URL
   /"localhost:54619/svg-display"/ and using the example from the
   previous section, the following Gui should be displayed:
   #+attr_html: :width 100%
   #+CAPTION: svg-display browser window
   #+NAME:   fig:svg-display
   [[./img/svg-display.png]]  

   Use the horizontal slider underneath the graphics to locate the
   cursor.

   There are five toggle buttons on the bottom left of the display:

   | ~play~ | Play the events starting at the cursor position or stop playback. Pressing the space bar on the keyboard is equivalent to clicking in the button. |
   | ~rtn~  | Mark/Unmark the current cursor position. If playback is stopped, the cursor will immediatly jump back to this position.                           |
   | ~pno~  | Display/Hide a Piano Roll background.                                                                                                             |
   | ~stf~  | Display/Hide s Staff System background: The black horizontal lines denote staff lines, the grey lines denote ledger lines.                        |
   | ~bar~  | Display/Hide Bar lines.                                                                                                                           |

   Note that like with any Clamps GUI, multiple browser windows with
   the same address can be opened simultaneously with synced
   graphics.

** cm-poolevt
   A [[dict:poolevt][poolevt]] is a sample event type like [[dict:sfz][sfz]]. In contrast to sfz, a
   poolevt implements granular transposition and stretching for
   playback.

#  TODO: In addition, a poolevt uses a /dy/ slot to enable a pitch-linear
#  glissando of the sample from start to end.

A poolevt also uses lsamples, but ignores their loop
   points. The sample to be played doesn't need to have a defined
   pitch. Nevertheless, it uses a keynum slot for SVG export. The
   transposition is determined by comparing the keynum of a poolevt
   instance with the keynum of its lsample[fn:11].

   #+BEGIN_SRC lisp
     (setq *flute-lsample*
       (create-lsample "69-Flute.nv.ff.1A4.wav" :keynum 69 :path (list (asdf:system-relative-pathname :clamps "extra/"))))
     ;; => *flute-lsample*

     (output
      (new poolevt
        :lsample *flute-lsample*
        :keynum 69))

     ;; => ; No value

     (output
      (new poolevt
        :lsample *flute-lsample*
        :keynum 69
        :stretch 3
        :wwidth 500))
     ;; => ; No value

     (output
      (new poolevt
        :lsample *flute-lsample*
        :keynum 67
        :stretch 3))
     ;; => ; No value

     (output
      (new poolevt
        :lsample *flute-lsample*
        :keynum 67
        :stretch 100
        :wwidth 27
        :amp -6))
     ;; => ; No value



     #+END_SRC

** cm-utils
   TBA
# ** cm-poolplayer
* Incudine Extensions
** General Incudine Setup
   :PROPERTIES:
   :DIR:      ~/work/programmieren/lisp/clamps/doc/img/./
   :END:
   When Clamps gets started, four groups, 100, 200, 300 and 400 are
   created in Incudine. They are placed in the dsp chain in
   chronological order:

   #+attr_html: :width 60%
   #+CAPTION: dsp chain after Clamps startup
   [[./img/clamps-dsp-chain.png]]

   Groups 100, 300 and 400 are intended for persistent dsps like
   levelmeters or buses.

   Pressing /<C-.>/ in emacs calls the function [[dict:node-free-unprotected][node-free-unprotected]]
   which frees all dsps in group 200, but /not/ any dsp in groups 100,
   300 or 400.

   As a consequence, dsps which should be stoppable with that keyboard
   shortcut have to be put into group 200 using the /:before/ or
   /:after/ keywords when starting the dsp.

   Dsps which should not be freed when pressing /<C-.>/ can be placed
   in groups 100, 300 and 400. Group 400 is defined for terminal dsps,
   e.g. endpoints of summing buses, which set the bus value to zero
   after they have output its value, whereas group 300 can be used for
   any persistent dsp which outputs to a bus or outlet.
** of-incudine-dsps
   of-incudine-dsps is a collection of Ugens and Dsps mainly concerned
   with buffer/sample playback. All Ugens and Dsps are implemented to
   work with any blocksize.

   The following Buffers, Envelopes, Ugens and Dsps are
   implemented. Click on the links in the left column to get further
   information.


   | Buffers                          |                                                                      |
   | [[dict:#hanning1024][*​hanning1024​*]]                    | 1024 point Hanning window                                            |
   | [[dict:#sine1024][*​sine1024​*]]                       | 1024 point Sine wave of one period                                   |
   |                                  |                                                                      |
   | Envelopes                        |                                                                      |
   | [[dict:#env1][*​env1​*]]                           | Simple ASR Envelope                                                  |
   |                                  |                                                                      |
   | Ugens                            |                                                                      |
   | [[dict:buffer-play*][buffer-play*]]                     | Ugen to play a buffer                                                |
   | [[dict:buffer-stretch-play*][buffer-stretch-play*]]             | Ugen to play a buffer with granular stretching applied               |
   | [[dict:envelope*][envelope*]]                        | Envelope Ugen                                                        |
   | [[dict:line*][line*]]                            | Line Ugen                                                            |
   | [[dict:phasor*][phasor*]]                          | Phasor Ugen                                                          |
   |                                  |                                                                      |
   | Dsps                             |                                                                      |
   | [[dict:play-buffer*][play-buffer*]]                     | Dsp to play a buffer                                                 |
   | [[dict:play-buffer-loop*][play-buffer-loop*]]                | Dsp to play a buffer with looping                                    |
   | [[dict:play-buffer-stretch*][play-buffer-stretch*]]             | Dsp to play a buffer with granular stretching                        |
   | [[dict:play-buffer-stretch-env-pan-out*][play-buffer-stretch-env-pan-out*]] | Dsp to play a buffer with granular stretching, attack, decay and pan |



   
** incudine-bufs

   clamps-bufs

   clamps-dsps
   
   incudine-bufs implements a registry for buffers in Clamps on top of
   Incudine's infrastructure for buffers.

   The standard way to add a buffer to the registry is using the
   command [[dict:clamps-buffer-load][clamps-buffer-load]]. The command takes a relative or
   absolute filename and a /:path/ key as arguments. The /:path/ is a
   list of pathnames of directories to search. Its default value is
   [[dict:#sfile-path][*​sfile-path​*]]. The user can push pathnames to that variable to add
   user- or application-specific locations to search for soundfiles.

   If a buffer of that name has already been loaded,
   clamps-buffer-load simply returns that buffer. Otherwise it loads
   the file into an incudine:buffer struct, assigns an unused integer
   /id/ to it, updates the registry and returns the loaded buffer:

#   #+HTML: <h4>Example</h4>
   #+BEGIN_SRC lisp
     (clamps-buffer-load
      "69-Flute.nv.ff.1A4.wav"
      :path (list (asdf:system-relative-pathname :clamps "extra/snd/")))
     ;; => #<incudine:buffer :FRAMES 112345 :CHANNELS 2 :SR 48000.0>
   #+END_SRC

   The buffer gets registered under its filename, full pathname and
   its id. A buffer can be retrieved from the registry using
   [[dict:find-buffer][find-buffer]] with any of the registered values as argument.

   In case a buffer has already been loaded (e.g. with Incudine's
   /#'buffer-load/ function), the function [[dict:add-buffer][add-buffer]] takes a buffer
   instead of a filename as argument and registers the buffer in the
   same way as clamps-buffer-load. [[dict:list-buffers][list-buffers]] lists all buffers and
   their ids, [[dict:buffer-id][buffer-id]] returns the id of a buffer, [[dict:remove-buffer][remove-buffer]]
   removes a buffer from the registry using its id, filename or the
   buffer itself as argument and [[dict:remove-all-buffers][remove-all-buffers]] removes all
   buffers from the registry.

   #+BEGIN_SRC lisp
     (defvar *73-flute-nv*
       (incudine:buffer-load
        (asdf:system-relative-pathname
         :clamps
         "extra/snd/sfz/Flute-nv/samples/73-Flute.nv.ff.1Db5.wav")))
     ;; => *73-flute-nv*

     (add-buffer *73-flute-nv*)
     ;; => #<incudine:buffer :FRAMES 114210 :CHANNELS 2 :SR 48000.0>

     (list-buffers)
     ;; => ((0 "69-Flute.nv.ff.1A4.wav" #<incudine:buffer :FRAMES 112345 :CHANNELS 2 :SR 48000.0>)
     ;;     (1 "73-Flute.nv.ff.1Db5.wav" #<incudine:buffer :FRAMES 114210 :CHANNELS 2 :SR 48000.0>))


     (find-buffer "69-Flute.nv.ff.1A4.wav")
     ;; => #<incudine:buffer :FRAMES 112345 :CHANNELS 2 :SR 48000.0>, t

     (buffer-id "69-Flute.nv.ff.1A4.wav")
     ;; => 0

     (find-buffer 0)
     ;; => #<incudine:buffer :FRAMES 112345 :CHANNELS 2 :SR 48000.0>, t

     (buffer-name (find-buffer "69-Flute.nv.ff.1A4.wav"))
     ;; => "69-Flute.nv.ff.1A4.wav"

     ;; compare to incudine's built-in function buffer-file:
     (buffer-file (find-buffer "69-Flute.nv.ff.1A4.wav"))
     ;; => #P"/home/orm/work/snd/sfz/transverse-flute/export/69-Flute.nv.ff.1A4.wav"

     (mapcar #'third (list-buffers))
     ;;  => (#<incudine:buffer :FRAMES 112345 :CHANNELS 2 :SR 48000.0>
     ;;      #<incudine:buffer :FRAMES 114210 :CHANNELS 2 :SR 48000.0>)

     (buffer-id #P"/home/orm/work/snd/sfz/transverse-flute/export/69-Flute.nv.ff.1A4.wav")
     ;; => 0

     (buffer-id (find-buffer "73-Flute.nv.ff.1Db5.wav"))
     ;; => 1

     (buffer-id "73-Flute.nv.ff.1Db5.wav")
     ;; => 1

     (buffer-id *73-flute-nv*)
     ;; => 1

     (remove-buffer 0)
     ;; => t

     (list-buffers)
     ;; => ((1 "73-Flute.nv.ff.1Db5.wav" #<incudine:buffer :FRAMES 114210 :CHANNELS 2 :SR 48000.0>))

     (remove-buffer *73-flute-nv*)
     ;; => t

     (list-buffers)
     ;; => nil

     ;; The buffer *73-flute-nv* is removed from the registry, but not
     ;; removed from clamps/incudine:

     (find-buffer *73-flute-nv*)
     ;; => nil

     *73-flute-nv*
     ;; => #<incudine:buffer :FRAMES 114210 :CHANNELS 2 :SR 48000.0>
   #+END_SRC

   #+HTML:<h4>Note</h4>
   The buffer containing "69-Flute.nv.ff.1A4.wav" also still exists
   after evaluating the code above, but if nothing points to it
   anymore, it will eventually get garbage collected. If the space of
   the buffer should get explicitely freed, use Incudine's #'free
   method with the buffer as argument.


* Gui
** General GUI Setup
   The gui is realized in a browser using the [[https://github.com/rabbibotton/clog][CLOG]] package available
   through quicklisp. A collection of [[clog-dsp-widgets][dsp-widgets]] has been implemented
   which realize the most common used gui elements for music, like
   Sliders, Buttons, VU Meters, etc. The implementation relies on
  [[cl-refs][ cl-refs]] to establish and handle the connection between the gui
   elements and the Common Lisp Code.
** clog-dsp-widgets
   TBA
** ats-cuda-display
   TBA
* Networking
** cuda-usocket-osc
   cuda-usocket-osc is a replacement for incudine's OSC architecture
   as that currently can't be used on OSX. It is a thin compatibility
   layer, reimplementing the most important functions of incudine
   using the Common Lisp /usocket/ library.

   cuda-usocket-osc gets automatically enabled when loading Clamps on
   OSX and can be enabled on Linux by pushing :cuda-usocket-osc to
   *​features​* before loading incudine. This can be achieved by putting
   the line below in the file /$HOME​/.clampsinit.lisp/:
   #+BEGIN_SRC lisp
   (pushnew :cuda-usocket-osc *features*)
   #+END_SRC
   If :cuda-usocket-osc is enabled, a line with the following content
   will be printed in the REPL when loading clamps:
   #+BEGIN_SRC lisp
     shadowing incudine.osc functions with cuda-usocket-osc
   #+END_SRC

   Note that this will not implement the full incudine osc framework!

** fudi
   TBA
* Misc Packages
** ats-cuda
   TBA
** cl-refs
   /cl-refs/ is a package dealing with the state (= value) of
   variables of an application and their synchronization.

   In Common Lisp, assigning a value to a symbol is called
   /binding/. The most common ways to bind a value to a symbol are
   using the special forms /let/, /setq/, /setf/, /defvar/,
   /defparameter/ or /defconstant/. During the course of running an
   application, the value bound to a symbol may change frequently as
   a consequence of user interaction or programmatic behaviour in
   certain situations, like reacting to external events, etc.[fn:12]
    
   Tracking those changes can be a challenging task, especially if
   the complexity of a program increases and values of different
   symbols need to be related to each other in a way that any change
   in one of these value should be reflected by the change of all
   other related values.

   /cl-refs/ addresses this task using a special class called
   /ref-object/ with customized access functions and additional
   functions defining relations and actions to be executed on value
   change. See the next sections for examples and implementation
   details.
*** A short example
   Let's consider a short example: A program defines two variables,
   /v1/ and /v2/. When changing one of these variables, the other
   variable doesn't change:
   #+BEGIN_SRC lisp
     (defvar v1 1) ; => v1

     (defvar v2 2) ; => v2

     v1 ; => 1
     v2 ; => 2

     (setf v1 3) ; => 3

     v1 ; => 3
     v2 ; => 2
   #+END_SRC
   The program wants to ensure, that /v2/ is always the double value
   of /v1/. This requires that we write some mechanism that changing
   one of the values also changes the other value. In a very naïve
   way we could do it like this:
   #+BEGIN_SRC lisp
     (defun set-v1 (value)
       (setf v1 value)
       (setf v2 (* 2 value))
       value)

     (defun set-v2 (value)
       (setf v2 value)
       (setf v1 (/ value 2))
       value)

     (set-v1 10) ; => 10

     v1 ; => 10
     v2 ; => 20

     (set-v2 30) ; => 30

     v1 ; => 15
     v2 ; => 30
   #+END_SRC
   Although this works, there are some problems with this approach:

   - For every relation two functions need to be defined, each of
     them needs to get a unique name and that can become cumbersome
     with an increasing number of variables in the program.

   - Changing a relation requires redefining all functions which use
     any of the related variables.

   - Linking more than two variables makes the definitions
     increasingly more complex and hard to maintain.

   Here is an example of an extension with a third variable /v3/
   defining the factor of the relation of /v1/ and /v2/
   #+BEGIN_SRC lisp
     (defparameter v3 2) ; => v3

     (defun set-v1 (value)
       (setf v1 value)
       (setf v2 (* v3 value))
       value)

     (defun set-v2 (value)
       (setf v2 value)
       (setf v1 (/ value v3))
       value)

     (defun set-v3 (value)
       (setf v3 value)
       (setf v2 (* v1 value))
       v3)

     (set-v3 4) ; => 4

     v1 ; => 15
     v2 ; => 60

     (set-v2 28) ; => 28

     v1 ; => 7
     v2 ; => 28
   #+END_SRC

   Now imagine /v3/ is dependant on another variable /v4/, or there
   is a chain of dependencies, in the worst case even resulting in a
   circular dependency, when /v4/ is dependent on the value of /v1/.
    
   Especially in a dynamic programming environment where relations
   between variables might frequently change during a session, the
   necessity of keeping track of all functions which need to be
   redefined and reevaluated to keep the variable state consistent
   becomes a major issue, making programs increasingly hard to
   maintain and debug.
*** The ref-object class
    To make this task less challenging, /cl-refs/ separates the
    definition of the variables and the application logic into
    distinct parts, automating the updating of variables behind the
    scenes. This makes the maintenance of the program much
    easier[fn:13].

    For a variable with possible relations to other variables,
    /cl-ref/ uses a special class called /ref-object/. Three main
    functions are defined to create and access a ref-object:
    A [[creation
     function][creation function]], a [[reader function][reader function]] and a [[setter function][setter function]]. These
    functions are always the same, regardless of the variable they
    apply to, so there is no need to define a new function for setting
    any of the variables as in the example in the previous section.

    #+HTML: <h5>creation function</h5>
    <<creation function>>

     A ref-object gets created with the function
     /make-ref/:
     #+BEGIN_SRC lisp
      (defparameter v1 (make-ref 1.0)) ; => v1

      v1 ; => #<ref 1.0>
     #+END_SRC

     #+HTML: <h5>reader function</h5>
     <<reader function>>

     To read the value of a ref-object, use the function /get-val/:
     #+BEGIN_SRC lisp
       (get-val v1)  ; => 1.0
     #+END_SRC
     #+HTML: <h5>setter function</h5>
     <<setter function>>
     To set the value of a ref-object, use the function /set-val/:
     #+BEGIN_SRC lisp
      (set-val v1 2.3)  ; => 2.3

      (get-val v1) ; => 2.3
     #+END_SRC
*** Defining relations
    /cl-refs/ provides two ways to define a relation between
    ref-objects, or between a ref-object and some program logic,
    [[make-computed][make-computed]] and [[watch][watch]].

    #+HTML: <h5>make-computed</h5>
    <<make-computed>>

    This function combines creating a new ref-object with establishing
    a relation between the created object and one or more other
    ref-objects. It takes a function as argument. All ref-objects
    referenced in the body of that function using /get-val/ will cause
    the newly created ref-object to update its value by calling the
    function whenever the value of any of these ref-objects is
    changed. /make-computed/ returns the newly created ref-object.
     #+BEGIN_SRC lisp
       (defvar c1 (make-ref 1.0)) ; => c1

       c1 ; => #<ref 1.0>

       (defvar c2 (make-computed (lambda () (* 2 (get-val c1)))))

       c2 ; => #<ref 2.0>

       (get-val c2) ; => 2.0

       (set-val c1 12) ; => 12

       (get-val c2) ; => 24

       ;;; NOTE: The other direction is undefined:

       (set-val c2 30) ; => 30

       (get-val c1) ; => 12 !!!
     #+END_SRC
     Here is an example using two related ref-objects:
     #+BEGIN_SRC lisp
       (defvar d1 (make-ref 1)) ; => d1
       (defvar d2 (make-ref -4)) ; => d2

       (defvar d3 (make-computed (lambda () (+ (get-val d1) (get-val d2))))) ; => d3

       (get-val d3) ; => -3

       (set-val d1 10) ; => 10

       (get-val d3) ; => 6

       (set-val d2 5) ; => 5

       (get-val d3) ; => 15
     #+END_SRC
     In case a two-way relation between ref-objects is needed,
     another function defining the reverse computation can be
     supplied as optional second argument to /make-computed/:
     #+BEGIN_SRC lisp
             (setf c2 (make-computed
                       ;; function called to set c2
                       ;; whenever any of the
                       ;; contained ref-objects are
                       ;; changed:
                       (lambda () (* 2 (get-val c1)))
                        ;; function called whenever c2 gets changed using
                        ;; (set-val c2 val):
                       (lambda (val) (set-val c1 (/ val 2)))))
       ; => #<ref 24>

             c2 ; => #<ref 24>

             (get-val c2) ; => 24

             (set-val c1 7) ; => 7

             (get-val c2) ; => 14

             ;;; Now the other direction works as well:

             (set-val c2 30) ; => 30

             (get-val c1) ; => 15
     #+END_SRC      
    #+HTML: <h5>watch</h5>
    <<watch>>
    
    Like /make-computed/ also /watch/ takes a function as
    argument. This function is called, whenever one or more
    ref-objects referenced in its body using /get-val/ are changed. In
    that way, actions can be triggered and associated with the change
    of ref-objects[fn:14]. Since actions can also involve changing
    other ref-objects, /watch/ can be used in a similar fashion as
    /make-computed/.

    Note that the call to /watch/ will trigger the execution of the
    supplied function once. This is necessary to register the function
    in the referenced ref-objects and to ensure the correct state of
    the application in case relations between ref-objects are defined
    within the function.

    /watch/ returns a function to remove the action defined by the
    supplied function. It is crucial to capture this result in order
    to be able to later remove the established connections between
    variables and associated actions[fn:15].

    #+HTML:<h5>Important Note</h5>
     
    Calling the same watch expression twice will establish two
    independent functions which will always be called on change of any
    contained ref-object. If the result of /watch/ wasn't captured,
    removing the defined function(s) is only possible by redefining
    all referenced objects with the result that any other relation
    previously established using /make-computed/ or /watch/ is
    referencing outdated ref-objects and will have to get
    redefined. Therefore it is not only advisable to capture the
    return value of all calls to watch, but also to put all
    definitions of ref-objects and their relations into a function or
    a piece of code reloadable at runtime to be able to reset all
    relations, preferably with additional code reestablishing a
    defined application state of all used ref-objects.
    #+BEGIN_SRC lisp
      (defvar e1 (make-ref 1)) ; => e1

      ;; Variable to capture watch definitions:
      (defvar unwatch nil) ; => unwatch

      (push (watch (lambda () (format t "e1 has changed to ~a~%" (get-val e1)))) unwatch)

      (set-val e1 40) ;; => 40

      ;; output in the REPL:
      ;; e1 has changed to 40

      unwatch ; => (#<function (lambda () :in watch) {1009EAD9DB}>)

      ;; define another action to be taken:

      (push
       (watch
        (lambda ()
          (format t "another relation: e1 has changed to ~a~%" (get-val e1))))
       unwatch)
      ;;  => (#<function (lambda () :in watch) {100D3F59DB}>
      ;;      #<function (lambda () :in watch) {1009EAD9DB}>)

      ;; output in the REPL:
      ;; another relation: e1 has changed to 40

      (set-val e1 10) ;; => 10

      ;; output in the REPL:
      ;; another relation: e1 has changed to 10
      ;; e1 has changed to 10

      ;; clear all connections by calling the functions returned by the call
      ;; to #'watch:

      (mapc #'funcall unwatch)

      (setf unwatch nil)

      (set-val e1 17) ;; => 17

      ;; No further output in the REPL.

    #+END_SRC
*** The bang-object class
    A bang-object is an extension to a ref-object by adding the option
    to trigger it. The inspiration for a bang object is an object
    which behaves like a button in a gui or on a hardware controller:
    In addition to the state of the button (on, off, flashing, etc.)
    which is captured in the value of its ref-object part, a button
    can be pressed. A button-press is realized by calling the [[dict:trigger][trigger]]
    function on an instance of the bang-object. Note that the
    triggered function is called without arguments and any value it
    returns is ignored by [[dict:trigger][trigger]]. It's called for its side-effect
    only.

    #+HTML: <h5>creation function</h5>
    <<creation function>>

     A bang-object gets created with the function /make-bang/. The
     optional arguments of the function are:

     1. A function of no arguments to be executed when calling [[dict:trigger][trigger]]
        with the created instance as argument.

     2. The initial value of the object, exactly like the argument to
        [[dict:make-ref][make-ref]].

     Here is an example:

     #+BEGIN_SRC lisp
       (defparameter b1 (make-bang (lambda () (msg :warn "Bang object b1 triggered")) 1)) ; => b1

       b1 ; => #<bang 1>

       (get-val b1) ; => 1
       (set-val b1 0) ; => 0
       (get-val b1) ; => 0

       (trigger b1) ; => nil
       ;; Output in the REPL:
       ;; warn: Bang object b1 triggered
     #+END_SRC

     When supplying /nil/ as the trigger function argument to
     make-bang, no action is taken when calling trigger on the created
     instance.

     [[dict:add-trigger-fn][add-trigger-fn]] takes at least two arguments: An instance of a
     bang-object and one or more functions of no argument, to be
     executed when the object is triggered.

     Like [[dict:watch][watch]] for the value part of a ref-object, [[dict:add-trigger-fn][add-trigger-fn]]
     returns a function of no arguments, which can be called to remove
     the added trigger-fn from the bang-object:

     #+BEGIN_SRC lisp
       (defparameter b1 (make-bang nil 0)) ; => b1

       b1 ; => #<bang 1>

       (trigger b1) ; => nil
       ;; No output in the REPL

       (defparameter *bang-unwatch-fn* nil)

       (setf *bang-unwatch-fn* (add-trigger-fn b1 (lambda () (msg :warn "Bang object b1 triggered"))))
       ;;  => #<function (lambda () :in add-trigger-fn) {100B72647B}>

       (trigger b1) ; => nil
       ;; Output in the REPL
       ;; warn: Bang object b1 triggered

       (funcall *bang-unwatch-fn*) ; => nil

       (trigger b1) ; => nil
       ;; No output in the REPL
     #+END_SRC
     
** cl-sfz
   cl-sfz implements the basic infrastructure to deal with [[https://en.wikipedia.org/wiki/SFZ_(file_format)][SFZ]]
   definitions. The SFZ format was developed in the context of
   software samplers. Like the sf2 format it defines a mapping of
   pitched samples to the keynums of a software synthesizer. If a
   sample is mapped to more than one keynum, the desired pitch is
   achieved by changing the playback speed of the sample.

   The SFZ format uses a plain text file to define keynum regions and
   their samples in addition to the base keynum, a pitch offset and an
   amplitude of the recording and other playback information[fn:7].

   #+Caption: Example of an entry for a keynum region in a SFZ file.
   #+BEGIN_SRC bash
     <region>
     sample=samples/p200-piano-d3-l-.wav
     lokey=35 hikey=38
     pitch_keycenter=38
     pan=-100
     ampeg_hold=2.80079
     ampeg_decay=44.9941
     ampeg_sustain=0.001
     offset=0
     end=193115
     loop_start=158947
     loop_end=193110
   #+END_SRC

   When loading a sfz file, Clamps parses this information from the
   file and creates an array of 128 lists containing [[dict:lsample][lsample]] structs
   as a lookup table for the 128 keynums. A lsample struct holds the
   /name/ of the sample, its loaded /buffer/, a /oneshot/ flag
   indicating whether to play back the lsample once or using the loop
   points, the /keynum/ of the buffer adjusted to the pitch-offset of
   the sfz entry, the /amplitude/ in dB of the sample and its /start-/
   and /endpoints/ for looping. Clamps keeps a list of lsample structs
   for each keynum, as the sfz format allows the mapping of more than
   one sample to the same keynum. When playing back an sfz entry,
   Clamps will randomly select the sample to use from this list.

   #+BEGIN_SRC lisp
     (first (aref (get-sfz-preset :yamaha-grand-piano) 35))
     ;;  => #S(lsample
     ;;        :name "p200-piano-d3-r-.wav"
     ;;        :buffer #<incudine:buffer :FRAMES 193116 :CHANNELS 1 :SR 32000.0>
     ;;        :oneshot nil
     ;;        :keynum 38.0d0
     ;;        :loopstart 158947.0d0
     ;;        :amp 0.0d0
     ;;        :loopend 193110.0d0)

   #+END_SRC

   Note that other features of the SFZ format like defining
   modulations, envelopes, etc. are currently ignored by the clamps
   importer.
*** Loading sfz files
    Clamps maintains an internal registry for sfz files, loading their
    samples into the system automatically when needed. The registry
    stores associations between a sfz preset name and the corresponding
    sfz file. Adding an association is done with the command
    [[dict:add-sfz-preset][add-sfz-preset]]:
    #+BEGIN_SRC lisp
      (add-sfz-preset :flute-nv "000_Flute_nv.sfz")
    #+END_SRC
    Loading a registered sfz-file will happen automatically when
    playing an sfz sound if its sfz file hasn't been loaded already:
    #+BEGIN_SRC lisp
      (play-sfz 60 0 3 :preset :fulte-nv) ;; => nil
      ;; output in the REPL:
      ;; loading :flute-nv from ~/quicklisp/local-projects/clamps/extra/snd/sfz/Flute-nv/000_Flute-nv.sfz
    #+END_SRC
    Loading an sfz file can also be issued directly using
    [[dict:get-sfz-preset][get-sfz-preset]], [[dict:ensure-sfz-preset][ensure-sfz-preset]] and
    [[dict:load-sfz-preset][load-sfz-preset]].

    get-sfz-preset and ensure-sfz-preset take the preset name as
    argument and require that the association between preset name and
    sfz file has already been made. load-sfz-preset takes the preset
    name and the sfz file as arguments and will register the preset
    and load the sfz file. If the preset is already registered it will
    behave exactly like get-sfz-preset or ensure-sfz-preset.

    sfz files will be searched recursively in all directories in the
    *​sfz-preset-path​* list.

    If a preset has already been loaded, it will not get reloaded
    unless the :force flag is set to non nil.

*** Playing sfz events

    The function [[dict:play-sfz][play-sfz]][fn:16] plays a sound from a sfz preset. It takes
    the a pitch, amplitude in dB and duration in seconds as
    arguments. The default preset is /:flute-nv/.  In addition it
    takes the keywords /:preset/, /:oneshot/, /:pan/, /:out1/ and
    /:out2/.
    #+BEGIN_SRC lisp
      (play-sfz 60 0 3) ;; => nil

      ;; play without looping
      (play-sfz 60 0 30 :preset :yamaha-grand-piano :oneshot t) ;; => nil


      ;; 30 seconds, left channel only

      #+END_SRC

       [[dict:play-sfz][play-sfz]] is a wrapper around  [[dict:play-lsample][play-lsample]].    
# ** cl-poolplayer
** cl-poolplayer
   TBA
** cl-plot
   TBA
** orm-utils
   orm-utils is a collection of utilities developed for general
   purpose use. Ist is included here for completeness only.

* Footnotes

[fn:1] Starting and stopping realtime processing can be achieved withqn
the Keyboard shortcuts /<C-c M-.>/ or /<C-c C-.>/

[fn:2] After all the MIDI input infrastructure of Clamps was built
on top of Incudine's infrastructure.

[fn:3] Be aware that most MIDI controllers and MIDI software don't
send /:note-off/ messages explicitely, but rather use a /:note-on/
message with a velocity of /0/ to denote a note off.

[fn:4] clamps' [[dict:start-midi-receive][start-midi-receive]] and [[dict:stop-midi-receive][stop-midi-receive]] are in fact merely wrappers around /recv-start/ and /recv-stop/.

[fn:5] When such an error happens in practice, it is often quite
puzzling what is at fault and such behaviour can be very hard to
debug. Therefore it is extremely important to be aware of the reasons
for such behaviour and to be alert when defining functions referencing
variables outside of their scope, expecially in iterations.

[fn:6] For examples see Dan Graham's famous book "On Lisp" or Doug
Hoyte's "Let over Lambda".

[fn:7] events are instances of objects derived from the /event/ class.

[fn:8]In the [[dict:events][events]] macro also lists or container classes like [[dict:seq][seq]] can
be used as event classes for output but they need to contain MIDI,
CLM, CMN or OSC events at some point in order to output anything.

[fn:9]Since Pure Data now supports OSC natively, the FUDI event class
is not required anymore and might be removed in the future.

[fn:10]The idea of typed output is inspired by [[https://en.wikipedia.org/wiki/Common_Lisp_Interface_Manager][CLIM]], the Common Lisp
Interface Manager, a central part of the Gui implementation of Lisp
Machines.

[fn:11] It is important to note that in SVG export the original keynum
   will be contained in the attributes field of every exported poolevt.

[fn:12] With the notable exception of a value bound by /defconstant/,
as a constant is an /immutable/ value, which never changes.

[fn:13] The implementation ideas are similar to javascript frameworks
which became increasingly popular in the 2010s like [[https://en.wikipedia.org/wiki/React_(JavaScript_library)][React]] or [[https://en.wikipedia.org/wiki/Vue.js][Vue.js]],
although they are rooted in much older concepts from the 1970s and
80s.

[fn:14] In Lisp parlance this is the classic example of a
/side-effect/.

[fn:15] For people used to patcher based systems like [[https://en.wikipedia.org/wiki/Pure_Data][Pure Data]] or
[[https://en.wikipedia.org/wiki/Max_(software)][Max/MSP]], /watch/ serves a similar purpose as patch cords in these
systems. Calling the function returned by /watch/ in that context is
similar to removing a patch cord, although the analogy shouldn't be
overstressed considering the significant differences between a
graph-based message-passing paradigm in these systems and the
structural layout of cl-ref/clamps.

[fn:16](play-sfz 60 0 20 :preset :yamaha-grand-piano :pan 0) ;; => nil
