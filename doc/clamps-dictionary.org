#+TITLE: Clamps Dictionary
#+AUTHOR: Orm Finnendahl
#+LANGUAGE: en
#+startup: entitiespretty
#+OPTIONS: html5-fancy:t
#+OPTIONS: num:nil
#+OPTIONS: toc:2 h:3 html-multipage-join-empty-bodies:t
#+OPTIONS: html-multipage-split:2
#+OPTIONS: html-multipage-toc-to-top:t
#+OPTIONS: html-multipage-export-directory:html/clamps-doc/clamps-dict
#+OPTIONS: html-multipage-open:nil
#+OPTIONS: html-multipage-numbered-filenames:nil
#+OPTIONS: html-preamble:"<a class=\"top-menu\" href=\"../overview/index.html\">Overview</a>\n<a class=\"top-menu\" href=\"../clamps/index.html\">Clamps Packages</a>\n<a class=\"top-menu\" href=\"../cm-dict/index.html\">CM Dictionary</a>\n<a class=\"top-menu top-menu-active\" href=\"./index.html\">Clamps Dictionary</a>\n<a class=\"top-menu\" href=\"../fomus/index.html\">Fomus</a>\n"
#+OPTIONS: html-toc-title:"Index"
#+OPTIONS: html-multipage-include-default-style:nil
#+HTML_DOCTYPE: xhtml5
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/clamps-dictionary.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/themes.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/htmlize.css" />
#+HTML_HEAD: <link href="./pagefind/pagefind-ui.css" rel="stylesheet">
#+HTML_HEAD: <script src="./pagefind/pagefind-ui.js"></script>
#+HTML_HEAD: <script src="../js/clamps-doc.js"></script>
# #+SETUPFILE: clamps-dict.setup
#+BEGIN_SRC emacs-lisp :exports results :results: none
  (load (format "%s%s" (file-name-directory (buffer-file-name))
                    "../extra/elisp/clamps-lookup.el"))
  (load (format "%s%s" (file-name-directory (buffer-file-name))
                    "../extra/elisp/clamps-links.el"))
  (load (format "%s%s" (file-name-directory (buffer-file-name))
                    "../extra/elisp/clamps-overview-lookup.el"))
  (defun extract-link (string)
  (if (= (aref (string-trim string) 0) 42)
      (replace-regexp-in-string "\\*​\\(.+\\)​\\*" "#\\1" string)
      string))
  (defun export-dict-to-clamps (s backend info)
    (let ((filename (buffer-file-name)))
      (with-temp-buffer
        (insert "(load \"~/quicklisp/local-projects/clamps/extra/elisp/cm-dict.el\")
  (mapcar
     (lambda (entry)
       (let ((symbol (intern (car entry)
    			 ,*common-music-symbols*)))
         (if (boundp symbol)
    	 (push (cadr entry) (symbol-value symbol))
           (set symbol (cdr entry)))))
     '(\n")
        (mapcar
         (lambda (entry)
           (insert
            (format "   (\"%s\" \"clamps-dict/%s\")\n"
                    (extract-link (org-html-element-title (car entry)))
                    (plist-get (cdr entry) :href))))
         (cl-remove-if
          (lambda (x) (= 1 (plist-get (cdr x) :relative-level)))
          (plist-get info :multipage-toc-lookup)))
        (insert "))\n")
        (write-region (point-min) (point-max) "../extra/elisp/clamps-dict.el"))
      (load (format "%s%s" (file-name-directory (buffer-file-name))
                    "../extra/elisp/clamps-dict.el"))
      s))
  (setq gc-cons-threshold 102400000)
  (setq max-lisp-eval-depth 10000)
#+END_SRC
#+BIND: org-export-filter-multipage-functions (export-dict-to-clamps)
#+BIND: org-html-htmlize-output-type css
# \[\[\([^\[]+\)\]\] → [[\1][\1]]
# C-x 8 RET 200b RET C-x 8 0

* Overview
** Notation and Usage

   The Clamps Dictionary has been inspired by the
   [[../cm-dict/index.html][CM Dictionary]], which was an original
   part of Common Music 2. Rather than interfering with the original,
   the additions of the Clamps package have been separated into their
   own pages here.

   Both dictionaries are accessed by the same Emacs keyboard shortcut
   /<C-c C-d c>/, issued from any lisp buffer with the cursor at the
   end of any Dictionary symbol after starting Clamps (see
   [[overview:Online Help System][Online Help System]]; the mechanism
   is integrated into the Clamps system when using the standard
   [[overview:Installation][Installation]]).

   The Notation of the Clamps Dictionary is simpler than the Notation
   used in the CM Dictionary. Function and Macro definitions use the
   definition syntax of the function or macro with the initial /defun/
   or /defmacro/ removed.

   Names of argumens in the /Arguments/ section of entries are printed
   in =red= and emphasized words appear in /green/.
* A
** add-buffer
   Function
   #+BEGIN_SRC lisp
     (add-buffer buf)
   #+END_SRC
   Add buffer to registry.
*** Arguments
    | =buf= | Incudine buffer. |

*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-id][buffer-id]]
    - [[buffer-name][buffer-name]]
    - [[bufname=][bufname=]]
    - [[clamps-buffer-load][clamps-buffer-load]]
    - [[find-buffer][find-buffer]]
    - [[list-buffers][list-buffers]]
    - [[remove-buffer][remove-buffer]]
    - [[remove-all-buffers][remove-all-buffers]]
** add-dsp
   Function
   #+BEGIN_SRC lisp
     (add-dsp dsp id &rest args)
   #+END_SRC
   Add a new instance of /dsp/ with id /id/ to the registry, optionally
   supplying the dsp creation with initialization arguments /args/.
*** Arguments
    | =dsp=  | The dsp type to add                                               |
    | =id=   | Keyword or Symbol to identify the registered dsp.                 |
    | =args= | Optional initialization arguments accepted by the used dsp class. |

*** See also
    - [[find-dsp][find-dsp]]
    - [[list-dsps][list-dsps]]
    - [[remove-dsp][remove-dsp]]
** add-elements
   Generic Function
   #+BEGIN_SRC lisp
     (add-elements container-obj &rest elems)
   #+END_SRC
   Add elements supplied either as svg-objects or as list(s) of svg-objects to /container-obj/.
*** Arguments
    | =container-obj= | Instance of an svg container.                                      |
    | =elems=         | One or more Instances of svg objects or lists of Instances to add. |

** add-midi-cc-fn
   Function
   #+BEGIN_SRC lisp
     (add-midi-cc-fn fn channel ccnum)
   #+END_SRC
   Add /fn/ to [[#midi-cc-fns][*​​midi-cc-fns​​*]] for /channel/ and /ccnum/.
   /fn/ will be called with the controller value as argument when MIDI
   input at /channel/ and /ccnum/ is received.
*** Arguments
    | =fn=      | Function of one Argument to call on MIDI input                     |
    | =channel= | Integer in the range [1..16] denoting the MIDI channel.            |
    | =ccnum=   | Integer in the range [1..128] denoting the MIDI Controller number. |

*** Example
    #+BEGIN_SRC lisp
      (add-midi-cc-fn
        (lambda (cc-val) (format t "Received Controller Value ~a~%" cc-val))
        1 1)
      ;; => (#<function (lambda (cc-val)) {564DA61B}>)
    #+END_SRC
*** See also
    - [[#midi-cc-fns][*​​midi-cc-fns​​*]]
    - [[remove-all-channel-midi-cc-fns][remove-all-channel-midi-cc-fns]]
    - [[remove-all-midi-cc-fns][remove-all-midi-cc-fns]]
    - [[remove-midi-cc-fns][remove-midi-cc-fns]]
    - [[show-midi-cc-fns][show-midi-cc-fns]]
** add-midi-controller
   Function
   #+BEGIN_SRC lisp
     (add-midi-controller class #:id &rest args)
   #+END_SRC
   Register a MIDI controller of class /class/ with ID /id/ and optional
   initialization argumens /args/.
*** Arguments
    | =class= | The class of the midi controller to add.            |
    | =id=    | Keyword or Symbol used as ID of the instance.       |
    | =args=  | Initialization arguments appropriate for the class. |

*** See also
    - [[list-midi-controllers][list-midi-controllers]]
    - [[find-controller][find-controller]]
    - [[midi-controller][midi-controller]]
    - [[remove-midi-controller][remove-midi-controller]]
    - [[remove-all-midi-controllers][remove-all-midi-controllers]]
** add-rts-hush-hook
   Function
   #+BEGIN_SRC lisp
     (add-rts-hush-hook &rest fns)
   #+END_SRC
   Add one ore more functions to rts-hush.
*** Arguments
    | =fns= | One or more functions to be called when invoking rts-hush. |

*** See also
    - [[remove-all-rts-hush-hooks][remove-all-rts-hush-hooks]]
    - [[rts-hush][rts-hush]]
    - [[show-rts-hush-hooks][show-rts-hush-hooks]]
** add-sfz-preset
   Function
   #+BEGIN_SRC lisp
     (add-sfz-preset preset file &key force)
   #+END_SRC
   Register the association between a sfz preset name /key/ and the
   /filename/ of its /.sfz/ file. The filename can be absolute or
   relative. If relative, all directories in [[#sfz-file-path][*​​sfz-file-path​​*]] will get
   searched recursively when the preset gets loaded.
   
   This function only stores the association between the preset name and
   its sfz file. Loading of its samples into memory is done implicitely
   when the preset is used by a playing function like [[play-sfz][#'play-sfz]] or
   by using [[ensure-sfz-preset][#'ensure-sfz-preset]] or its synonym [[get-sfz-preset][#'get-sfz-preset]].
*** Arguments
    | =preset= | A Keyword or Symbol to name the preset           |
    | =file=   | A String or Pathname to the associated sfz file. |

*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
    - [[load-sfz-preset][load-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
    - [[sfz][sfz]]
    - [[sfz-get-range][sfz-get-range]]
    - [[sfz-preset-file][sfz-preset-file]]
    - [[sfz-preset-loaded?][sfz-preset-loaded?]]
    - [[#sfz-file-path][*​​sfz-file-path​​*]]
** add-trigger-fn
   Function
   #+BEGIN_SRC lisp
     (add-trigger-fn ref &rest fns)
   #+END_SRC
   Add one or more /fns/ to be executed when /ref/ is called with the
   #'trigger function. The function returns a function removing the
   trigger function(s) from ref, comparable to the [[watch][watch]] function on
   a <ref-object>>.
*** Arguments
    | =ref= | A [[bang-object][bang-object]].                                                                             |
    | =fns= | one or more functions of zero argument called when the trigger function is invoked on ref. |

*** See also
    - [[make-bang][make-bang]]
    - [[remove-all-triggers][remove-all-triggers]]
    - [[remove-trigger-fn][remove-trigger-fn]]
** all-notes-off
   Function
   #+BEGIN_SRC lisp
     (all-notes-off)
   #+END_SRC
   Send an all-notes-off cc message to all 16 channels of *​rts-out​*.
*** See also
    - [[rts-hush][rts-hush]]
** all-permutations
   Function
   #+BEGIN_SRC lisp
     (all-permutations list &key (test #'eql) (max-length 10))
   #+END_SRC
   Get all permutations of /list/. Make sure to supply a /test/
   function in case the elements can't be compared with #'eql, otherwise
   the function will blow the stack. /max-length/ is the maximum length
   of /list/ accepted. This serves as a safety measure to avoid making
   the lisp process unresponsive due to an excessive number of
   permutations.
*** Arguments
    | =list=        | List of elements to be permuted.                           |
    | =:test=       | Function to test for equality of elements in list.         |
    | =:max-length= | Positive Integer denoting maximum length of list accepted. |

*** Examples
    #+BEGIN_SRC lisp
      (all-permutations (range 4))
      ;; => ((0 1 2 3) (0 1 3 2) (0 2 1 3) (0 2 3 1) (0 3 1 2) (0 3 2 1) (1 0 2 3)
      ;; (1 0 3 2) (1 2 0 3) (1 2 3 0) (1 3 0 2) (1 3 2 0) (2 0 1 3) (2 0 3 1)
      ;; (2 1 0 3) (2 1 3 0) (2 3 0 1) (2 3 1 0) (3 0 1 2) (3 0 2 1) (3 1 0 2)
      ;; (3 1 2 0) (3 2 0 1) (3 2 1 0))
      
      (all-permutations (range 20))
      ;;
      ;; => Error: list to be permuted exceeds maximum length.
    #+END_SRC
** amp->db
   Function
   #+BEGIN_SRC lisp
     (amp->db amp)
   #+END_SRC
   Return dB value of linear amplitude /amp/. An amplitude of 0 returns a
   dB value of -100.
*** Arguments
    | =amp= | Positive Integer denoting linear amplitude. |

*** Example
    #+BEGIN_SRC lisp
      (amp->db 1) ; => 0.0
      (amp->db 0) ;= -100
    #+END_SRC
** amp->db-slider
   Function
   #+BEGIN_SRC lisp
     (amp->db-slider amp &key (min -40) (max 12))
   #+END_SRC
** array-slice
   Function
   #+BEGIN_SRC lisp
     (array-slice arr row-idx)
   #+END_SRC
   Return the row with index /row-idx/ of a 2-dimensional array as
   1-dimensional array, sharing the same data structure by utilizing
   Common Lisp's displaced array functionality.
*** Arguments
    | =arr=     | 2-dimensional Array.                                          |
    | =row-idx= | Non Negative Integer denoting the Index of the row to return. |

** ats->browser
   Function
   #+BEGIN_SRC lisp
     (ats->browser ats-snd &key (reload t))
   #+END_SRC
   Display the ats struct /ats-snd/ graphically in the interactive ATS
   Player located at /<clamps-base-url>/ats-display/ in the Gui.
*** Arguments
    | =ats-snd= | The ats struct to display. |

*** See also
    - [[clamps-base-url][clamps-base-url]]
** ats->svg
   Function
   #+BEGIN_SRC lisp
     (ats->svg ats-sound &key (brightness 20) x-scale (width 960) (height 540) fname)
   #+END_SRC
   Generate a SVG file of the <ats-sound> and save it at "/tmp/www/svg/ats.svg"
** *​ats-file-path​*
   :PROPERTIES:
   :CUSTOM_ID: ats-file-path
   :END:
   Variable

   List of directories to search recursively for ats files.
*** See also
    - [[load-ats][load-ats]]
** ats-sound
   Structure

   Structure of an ATS sound. The access functions use the standard
   scheme /ats-sound-<slot-name>/.
*** Slots
    | =name=            | String denoting the filename of the analyzed sound.                                                                                 |
    | =sampling-rate=   | Positive Number denoting the sample rate of the analyzed sound.                                                                     |
    | =frame-size=      | Number denoting the Frame Size in samples.                                                                                          |
    | =window-size=     | Number denoting the Analysis Window Size in samples.                                                                                |
    | =partials=        | Number of tracks in the analyzed sound.                                                                                             |
    | =frames=          | number of frames in the analyzed sound (duration/window-size).                                                                      |
    | =bands=           | List containing the indexes of noise bands of the residual outside of the noise energy contained in the tracks.                     |
    | =optimized=       | Boolean indicating whether the sound was optimized in the analysis.                                                                 |
    | =ampmax=          | Maximum overall amplitude.                                                                                                          |
    | =frqmax=          | Maximum overall frequency.                                                                                                          |
    | =frq-av=          | Array of size <partial> containing the average frequency for each track.                                                            |
    | =amp-av=          | Array of size <partial> containing the average amplitude for each track.                                                            |
    | =dur=             | Positive Number indicateing the duration of the analyzed sound in seconds.                                                          |
    | =time=            | 2-dimensional Array of size <partial> <frames> containing the time into the analyzed sound in seconds for each frame in each track. |
    | =frq=             | 2-dimensional Array of size <partial> <frames> containing the frequency for each frame in each track.                               |
    | =amp=             | 2-dimensional Array of size <partial> <frames> containing the amplitude for each frame in each track.                               |
    | =pha=             | 2-dimensional Array of size <partial> <frames> containing the phase for each frame in each track.                                   |
    | =energy=          | Boolean indicating whether residual energy was analyzed and mapped to the tracks.                                                   |
    | =band-energy=     | 2-dimensional Array of size <partial> <frames> containing the phase for each frame in each track.                                   |
    | =analysis-params= | Property list with the parameters given to the track-ats function.                                                                  |

*** See also
    - [[track-ats][track-ats]]
    - [[load-ats][load-ats]]
    - [[save-ats][save-ats]]
** audio-bus
   Generic Function
   #+BEGIN_SRC lisp
     (audio-bus object)
   #+END_SRC
   automatically generated reader method
* B
** bang-object
   Class
   #+BEGIN_SRC lisp
     (bang-object)
   #+END_SRC
   A /bang-object/ is a special class used in the /cl-refs/
   package. It extends the slots of a [[ref-object][ref-object]] with a slot
   /trigger-fns/, a list of functions called when the function
   [[trigger][trigger]] is called with the bang-object as argument. The slots of a
   bang-object shouldn't be accessed or manipulated directly, but rather
   using the public functions of the cl-refs package listed below. A
   bang-object should get instantiated using the [[make-bang][make-bang]] function.
   
   For information how to use bang-objects refer to [[clamps:cl-refs][cl-refs]] in
   the Clamps Packages documentation.
*** See also
    - [[get-val][get-val]]
    - [[make-bang][make-bang]]
    - [[set-val][set-val]]
    - [[trigger][trigger]]
    - [[watch][watch]]
** bind-ref-to-attr
   Generic Function
   #+BEGIN_SRC lisp
     (bind-ref-to-attr refvar attr &optional map)
   #+END_SRC
** bind-refs-to-attrs
   Function
   #+BEGIN_SRC lisp
     (bind-refs-to-attrs &rest refs-and-attrs)
   #+END_SRC
** *​bindings​*
   :PROPERTIES:
   :CUSTOM_ID: bindings
   :END:
   Variable

** bool
   Function
   #+BEGIN_SRC lisp
     (bool pred)
   #+END_SRC
   Enforce /t/ or /nil/ on pred.
*** Arguments
    | =pred= | Any lisp expression. |

*** Examples
    #+BEGIN_SRC lisp
      (bool 1) ; => t
      (bool nil) ; => nil
    #+END_SRC
** buchla-scale
   Function
   #+BEGIN_SRC lisp
     (buchla-scale curr old target &key (max 127))
   #+END_SRC
   Set /target/ fader by interpolating between 0 and /max/, using
   the /curr/ and /old/ values of a source fader.
   
   The function serves the purpose of avoiding jumps when working with
   non motorized hardware faders: If the value of the software target
   of the hardware fader has changed (e.g. by a preset or some program
   logic) without the hardware fader being updated, moving the
   hardware fader will not cause a jump in the target:
   
   If the hardware fader moves up (> curr old), the remaining space
   above the fader will interpolate the target software fader between
   its current value and the maximum value, if it moves down (< curr
   old), the software target will be interpolated between the current
   value and 0 using the remaining space below the hardware fader.
** buffer-dur
   Function
   #+BEGIN_SRC lisp
     (buffer-dur buffer)
   #+END_SRC
   Return duration of /buffer/ in seconds.
*** Arguments
    | =buffer= | Incudine buffer struct. |

*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[add-buffer][add-buffer]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-id][buffer-id]]
    - [[buffer-name][buffer-name]]
    - [[bufname=][bufname=]]
    - [[clamps-buffer-load][clamps-buffer-load]]
    - [[find-buffer][find-buffer]]
    - [[list-buffers][list-buffers]]
    - [[remove-buffer][remove-buffer]]
    - [[remove-all-buffers][remove-all-buffers]]
** buffer-id
   Function
   #+BEGIN_SRC lisp
     (buffer-id ref)
   #+END_SRC
   Return index of buffer /ref/ from registry. ref can be the filename of
   a buffer or the buffer itself.
*** Arguments
    | =buffer= | Incudine buffer, Pathname or String denoting the filename of the buffer. |

*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[add-buffer][add-buffer]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-name][buffer-name]]
    - [[bufname=][bufname=]]
    - [[clamps-buffer-load][clamps-buffer-load]]
    - [[find-buffer][find-buffer]]
    - [[list-buffers][list-buffers]]
    - [[remove-buffer][remove-buffer]]
    - [[remove-all-buffers][remove-all-buffers]]
** buffer-loop-play*
   :PROPERTIES:
   :CUSTOM_ID: buffer-loop-play
   :END:
   Incudine VUG
   #+BEGIN_SRC lisp
     (buffer-loop-play* (buffer buffer) (rate sample) (start-pos sample) (loopstart sample) (loopend sample))
   #+END_SRC
   Buffer loop play Ugen working with any blocksize.
*** Arguments
    | =buffer=    | Incudine buffer.                                                                  |
    | =rate=      | Positive Number denoting playback rate (will get adjusted to buffer-sample-rate). |
    | =start-pos= | Non Negative Integer denoting start position in samples.                          |
    | =loopstart= | Non Negative Integer denoting start of loop in samples.                           |
    | =loopend=   | Non Negative Integer denoting end of loop in samples.                             |

*** See also
    - [[#buffer-play][buffer-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#line][line​*]]
    - [[#phasor][phasor​*]]
    - [[#phasor-loop][phasor-loop​*]]
    - [[#play-buffer][play-buffer​*]]
    - [[#play-buffer-loop][play-buffer-loop​*]]
    - [[#play-buffer-stretch][play-buffer-stretch​*]]
    - [[#play-buffer-stretch-env-pan-out][play-buffer-stretch-env-pan-out​*]]
** buffer-name
   Function
   #+BEGIN_SRC lisp
     (buffer-name buffer)
   #+END_SRC
   Return the file-namestring of /buffer/.
*** Arguments
    | =buffer= | Incudine buffer. |

*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[add-buffer][add-buffer]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-id][buffer-id]]
    - [[bufname=][bufname=]]
    - [[find-buffer][find-buffer]]
    - [[list-buffers][list-buffers]]
    - [[remove-buffer][remove-buffer]]
    - [[remove-all-buffers][remove-all-buffers]]
** buffer-play*
   :PROPERTIES:
   :CUSTOM_ID: buffer-play
   :END:
   Incudine VUG
   #+BEGIN_SRC lisp
     (buffer-play* (buffer buffer) (rate sample) (startframe sample) (endframe sample))
   #+END_SRC
   Buffer play Ugen working with any blocksize.
*** Arguments
    | =buffer=      | Incudine buffer.                                                                  |
    | =rate=        | Positive Number denoting playback rate (will get adjusted to buffer-sample-rate). |
    | =start-frame= | Non Negative Integer denoting start position of playback in samples.              |
    | =endframe=    | Non Negative Integer denoting end position of playback in samples.                |

*** See also
    - [[#buffer-loop-play][buffer-loop-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#line][line​*]]
    - [[#phasor][phasor​*]]
    - [[#phasor-loop][phasor-loop​*]]
    - [[#play-buffer][play-buffer​*]]
    - [[#play-buffer-loop][play-buffer-loop​*]]
    - [[#play-buffer-stretch][play-buffer-stretch​*]]
    - [[#play-buffer-stretch-env-pan-out][play-buffer-stretch-env-pan-out​*]]
** buffer-record
   Function
   #+BEGIN_SRC lisp
     (buffer-record &rest optional-keywords &aux (#:lambda-list '((buf (incudine-missing-arg "buffer") (env *env1*) (in 0) (start 0) (frames 0) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** buffer-stretch-play*
   :PROPERTIES:
   :CUSTOM_ID: buffer-stretch-play
   :END:
   Incudine VUG
   #+BEGIN_SRC lisp
     (buffer-stretch-play* (buffer buffer) (rate sample) (wwidth sample) (start sample) (end sample) (stretch sample))
   #+END_SRC
   Buffer play Ugen with granular stretching working with any blocksize.
*** Arguments
    | =buffer=  | Incudine buffer.                                                                  |
    | =rate=    | Positive Number denoting playback rate (will get adjusted to buffer-sample-rate). |
    | =wwidth=  | Non Negative Integer denoting granular window size in msecs.                      |
    | =start=   | Non Negative Integer denoting start of playback into the buffer in samples.       |
    | =end=     | Non Negative Integer denoting end of playback into the buffer in samples.         |
    | =stretch= | Positive Integer denoting stretching factor.                                      |

*** See also
    - [[#buffer-loop-play][buffer-loop-play​*]]
    - [[#buffer-play][buffer-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#line][line​*]]
    - [[#phasor][phasor​*]]
    - [[#phasor-loop][phasor-loop​*]]
    - [[#play-buffer][play-buffer​*]]
    - [[#play-buffer-loop][play-buffer-loop​*]]
    - [[#play-buffer-stretch][play-buffer-stretch​*]]
    - [[#play-buffer-stretch-env-pan-out][play-buffer-stretch-env-pan-out​*]]
** bufname=
   Function
   #+BEGIN_SRC lisp
     (bufname= buf file)
   #+END_SRC
   Compare /file/ with the filename of /buf/. If buf is a list, compare
   file to the filenames of all elements of list and return buf if any is
   matching.
*** Arguments
    | =buf=  | Incudine:buffer           |
    | =file= | String denoting the file. |

*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[add-buffer][add-buffer]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-id][buffer-id]]
    - [[buffer-name][buffer-name]]
    - [[clamps-buffer-load][clamps-buffer-load]]
    - [[find-buffer][find-buffer]]
    - [[list-buffers][list-buffers]]
    - [[remove-buffer][remove-buffer]]
    - [[remove-all-buffers][remove-all-buffers]]
** bus-name
   Generic Function
   #+BEGIN_SRC lisp
     (bus-name object)
   #+END_SRC
   automatically generated reader method
** bus-to-out
   Function
   #+BEGIN_SRC lisp
     (bus-to-out numchannels startidx &key id head tail before after replace action stop-hook free-hook fade-time fade-curve)
   #+END_SRC
** bus-value
   Function
   #+BEGIN_SRC lisp
     (bus-value channel)
   #+END_SRC
   if blocksize > 1 returns the value of bus for current-frame.
* C
** calcsndbytes
   Function
   #+BEGIN_SRC lisp
     (calcsndbytes hr min sec &key (samplerate 44100) (bytes-per-sample 4))
   #+END_SRC
   Return the number of bytes (not samples!) from /hr/, /min/ and
   /sec/. Samplerate and the number of bytes per sample can be supplied
   using the /samplerate/ and /bytes-per-sample/ keywords..
*** Arguments
    | =hr=               | Number of hours.              |
    | =min=              | Number of minutes.            |
    | =hr=               | Number of seconds.            |
    | =samplerate=       | Number of samples per second. |
    | =bytes-per-sample= | Number of bytes per sample.   |

*** Example
    #+BEGIN_SRC lisp
      (calcsndbytes 0 1 10) ; => 12348000
    #+END_SRC
** call/collecting
   Function
   #+BEGIN_SRC lisp
     (call/collecting f n &optional (tail '()))
   #+END_SRC
   Call function /f/ /n/ times, with idx [0..n-1] as argument,
   collecting its results. Return results with /tail/ appended.
*** Arguments
    | =f=    | Function of one argument (an integer in the range [0..n]) |
    | =n=    | Positive integer                                          |
    | =tail= | A list collected into by prepending to it                 |

*** Examples
    #+BEGIN_SRC lisp
      (call/collecting (lambda (x) (* x x)) 4) ; => (0 1 4 9)
      
      (call/collecting (lambda (x) (1+ x)) 4 '(hi)) ; => (1 2 3 4 hi)
    #+END_SRC
*** See also
    - [[v-collect][v-collect]]
** case-ext
   Macro
   #+BEGIN_SRC lisp
     (case-ext keyform test &rest body)
   #+END_SRC
   case with compare function as second element.
** ccin
   Function
   #+BEGIN_SRC lisp
     (ccin ccnum &optional (channel *default-midi-channel*) (midi-port *default-midi-port*))
   #+END_SRC
   Return the last received MIDI CC value of controller number /ccnum/
   at MIDI channel /channel/ of /midi-port/. Setfable.
*** Arguments
    | =ccnum=     | Integer in the range [1..128] indicating the Controller Number.                    |
    | =channel=   | Integer in the range [1..16] indicating the MIDI channel.                          |
    | =midi-port= | Instance of type midi-port or Keyword denoting the id of the registered midi-port. |

*** See also
    - [[#midi-cc-state][*​​midi-cc-state​​*]]
** cd
   Function
   #+BEGIN_SRC lisp
     (cd &optional (dirarg (user-homedir-pathname)))
   #+END_SRC
   Change the current working directory to /dirarg/ or to $HOME if dirarg
   is not supplied.
*** Arguments
    | =dirarg= | String or Pathname. |

*** See also
    - [[pwd][pwd]]
** chan
   Generic Function
   #+BEGIN_SRC lisp
     (chan object)
   #+END_SRC
   Accessor method for the chan slot of an instance of type
   [[midi-controller][midi-controller]].
** clamps
   Function
   #+BEGIN_SRC lisp
     (clamps &key (gui-base "/tmp") (qsynth nil) (open-gui nil))
   #+END_SRC
   Start Clamps including the Gui. This function can be called from the
   /:cl-user/ package.
   
   Apart from starting the webserver for the Gui, the function also:
   
   - Starts the OSC responder for Inkscape.
   - Starts the realtime engine and sets up MIDI ports and receivers by calling [[rts][rts]].
   - Creates groups and buses for incudine dsps (see the Chapter [[clamps:General Incudine Setup][General Incudine Setup]].
   - Starts the documentation acceptor for the online doc at /http://localhost:8282/overview/index.html/.
   
   The following directories will be created in the /gui-base/ path if
   they don't exist:
   
   - /<gui-base>/ats//
   - /<gui-base>/snd//
   - /<gui-base>/www//
   - /<gui-base>/www/svg//
   
   The latter is the file path for svg files used in the
   /<clamps-base-url>/svg-display/ page of the Gui.
   
   Any files which need to be accessible by the Gui have to be put into
   the /<gui-base>/www// subdirectory with their filenames relative to
   this directory.
*** Arguments
    | =:gui-base= | String or Pathname indicating where to put the /www/ subfolder for files accessible by the gui (nicknamed /<clamps-gui-root>/). |
    | =:open-gui= | Boolean indicating whether to open the /<clamps-base-url>/ in a browser window after starting the gui.                          |
    | =:qsynth=   | Boolean indicating whether to start the Qsynth softsynth (Linux only).                                                          |

*** See also
    - [[clamps-base-url][clamps-base-url]]
    - [[clamps-restart-gui][clamps-restart-gui]]
    - [[clamps-start][clamps-start]]
    - [[clamps-gui-root][clamps-gui-root]]
    - [[rts][rts]]
** clamps-base-url
   Function
   #+BEGIN_SRC lisp
     (clamps-base-url)
   #+END_SRC
   Return the base url to access the Clamps Gui (nicknamed
   /<clamps-base-url>/ in this dictionary).
   
   Its default location is http://localhost:54619.
   
   /<clamps-base-url>/ on the browser side is corresponding to the
   path /<clamps-gui-root>/, so an address named
   /<clamps-base-url>/<file>/ will load the file located at
   /<clamps-gui-root>/<file>/ as HTML into the browser window.
   
   The location for the [[svg->browser][SVG Player Gui]] is at
   /<clamps-base-url>/svg-display/ which translates to the URL
   
   http://localhost:54619/svg-display
*** See also
    - [[clamps][clamps]]
    - [[clamps-restart-gui][clamps-restart-gui]]
    - [[clamps-gui-root][clamps-gui-root]]
    - [[gui][gui]]
    - [[meters][meters]]
** clamps-buffer-load
   Function
   #+BEGIN_SRC lisp
     (clamps-buffer-load file &key (path *sfile-path*))
   #+END_SRC
   Load and register buffer from /file/ if not loaded already. Return
   buffer. /file/ will be searched recursively in all directories of
   [[#sfile-path][*​​sfile-path​​*]].
*** Arguments
    | =file=  | Pathname or String denoting a soundfile.         |
    | =:path= | List of Pathnames or Strings to search for file. |

*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[add-buffer][add-buffer]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-id][buffer-id]]
    - [[find-buffer][find-buffer]]
    - [[buffer-name][buffer-name]]
    - [[bufname=][bufname=]]
    - [[list-buffers][list-buffers]]
    - [[remove-buffer][remove-buffer]]
    - [[remove-all-buffers][remove-all-buffers]]
    - [[#sfile-path][*​​sfile-path​​*]]
** clamps-gui-root
   Function
   #+BEGIN_SRC lisp
     (clamps-gui-root)
   #+END_SRC
   Return the pathname of the Gui root directory. It is nicknamed
   /<clamps-gui-root>/ throughout this dictionary.
   
   /<clamps-gui-root>/ is the path corresponding to
   /<clamps-base-url>/ on the browser side, so any file named /<file>/
   put into the /<clamps-gui-root>/ directory can be accessed in the
   browser at the address /<clamps-base-url>/<file>/.
*** See also
    - [[clamps][clamps]]
    - [[clamps-base-url][clamps-base-url]]
    - [[clamps-restart-gui][clamps-restart-gui]]
** clamps-restart-gui
   Function
   #+BEGIN_SRC lisp
     (clamps-restart-gui &key (gui-base "/tmp") (open t) (port 54619))
   #+END_SRC
   Reset the root directory of the Gui to /<gui-base>/www//, optionally
   opening the Gui in a browser window. The command will create the
   subdirectories /www//, /snd//, /ats// and /www/svg// in the
   /<gui-base>/ directory, if they don't exist. /<gui-base>/www/svg// is
   the file path for svg files used in the /svg-display/ page of the Gui.
*** Arguments
    | =:gui-base= | String or Pathname where to put the /www/ subfolder for files accessible by the gui (nicknamed /<clamps-gui-root>/ throughout this dictionary). Defaults to //tmp/.                                                                                               |
    | =:open=     | is a flag indicating whether to open [[clamps-base-url][clamps-base-url]] in a browser window after starting the gui.  Any files which need to be accessible by the Gui have to be put into the /<clamps-gui-base>/www// subdirectory with their filenames relative to this directory. |

*** See also
    - [[clamps][clamps]]
    - [[clamps-base-url][clamps-base-url]]
    - [[clamps-gui-root][clamps-gui-root]]
** clamps-start
   Function
   #+BEGIN_SRC lisp
     (clamps-start &key (gui-base "/tmp") (qsynth nil) (open-gui nil) (port 54619))
   #+END_SRC
   Entry function called by [[clamps][clamps]] to start the webserver for the
   GUI, call [[rts][rts]] to set up IO and MIDI, start the OSC responder for
   Incudine, optionally start qsynth (Linux only) and open the gui in a
   browser. This function should normally not be called by the user.
*** Arguments
    | =gui-base= | The base path of the gui. <clamps-gui-root> will be <gui-base>/www/.   |
    | =qsynth=   | Boolean indicating whether to start the qsynth softsynth (Linux only). |
    | =open-gui= | Boolean indicating whether to open the gui in a Browser window.        |

*** See also
    - [[clamps][clamps]]
    - [[clamps-gui-root][clamps-gui-root]]
    - [[rts][rts]]
** clear-bindings
   Function
   #+BEGIN_SRC lisp
     (clear-bindings)
   #+END_SRC
** clear-buses
   Function
   #+BEGIN_SRC lisp
     (clear-buses &rest optional-keywords &aux (#:lambda-list '((startidx 16 (numchannels 8) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** clear-dependencies
   Function
   #+BEGIN_SRC lisp
     (clear-dependencies co cb)
   #+END_SRC
   clear all dependencies of a computed ref object.
** clip
   Function
   #+BEGIN_SRC lisp
     (clip val min max)
   #+END_SRC
** clog-midi-controller
   Class

   Base Class for the Gui instance of a MIDI controller. Note that each
   open Gui window will create a new instance of all
   clog-midi-controllers it contains. Multiple instances of the same
   clog-midi-controller in different GUi windows will all share the same
   midi-controller instance.
   
   clog-midi-controller implements the following slots with initargs
   being the keywords of the slot symbol:
   
   =midi-controller= -- The midi controller instance of [[clamps:cl-midictl][cl-midictl]], its class derived from [[midi-controller][midi-controller]].
   
   =connection-hash-key= -- A read-only slot containing the hash key of the web connection of the Gui instance.
*** Note
    Any update of any Gui element in any connected Gui window will call
    the [[set-val][set-val]] function of the corresponding [[ref-object][ref-object]] in a slot
    of the shared midi-controller instance, automatically triggering
    updates of the same Gui Element in all other connected Gui windows.
    
*** See also
    - [[m-controller][m-controller]]
** close
   Function
   #+BEGIN_SRC lisp
     (close stream)
   #+END_SRC
** close-midi-port
   Function
   #+BEGIN_SRC lisp
     (close-midi-port #:id)
   #+END_SRC
   Remove a midi port denoted by /id/. Return t if successful.
*** Arguments
    | =id= | Keyword or Symbol denoting the id of the midi port. |

*** See also
    - [[find-midi-port][find-midi-port]]
    - [[list-midi-ports][list-midi-ports]]
    - [[open-midi-port][open-midi-port]]
** collect-pool
   Function
   #+BEGIN_SRC lisp
     (collect-pool &rest keys)
   #+END_SRC
** combinations
   Function
   #+BEGIN_SRC lisp
     (combinations seq &optional (n 2))
   #+END_SRC
   Get all n combinations of seq.
** construct-plot-command
   Function
   #+BEGIN_SRC lisp
     (construct-plot-command &key region (grid t) (header *gnuplot-header*) (options *gnuplot-options*) &allow-other-keys)
   #+END_SRC
   Helper function to construct the gnuplot command with a given
   header, options and a grid flag.
** copy-instance
   Generic Function
   #+BEGIN_SRC lisp
     (copy-instance object &rest initargs &key &allow-other-keys)
   #+END_SRC
** copy-ref
   Function
   #+BEGIN_SRC lisp
     (copy-ref ref)
   #+END_SRC
** count-elements
   Function
   #+BEGIN_SRC lisp
     (count-elements seq &key (test #'eql) (key #'identity) (sort t))
   #+END_SRC
   Count the number of occurences of all mutually equal elems in
   /seq/ extracted from its items according to the /key/ function and
   satisfying the /test/ function as predicate. Return the results as
   list with sublists of the form (elem count) for each elem, optionally
   sorted according to the setting of /sort/.
*** Arguments
    | =seq=   | A Common Lisp Sequence.                                                       |
    | =:test= | Function accepted as test function by #'make-hash-table.                      |
    | =:key=  | Function to extract the key to compare from each element.                     |
    | =:sort= | Boolean indicationg whether and how to sort the results. Possible Values are: |
    |         | /:from-end/                                                                   |
    |         | /t/                                                                           |
    |         | /nil/                                                                         |

   If /:sort/ is /nil/, result returns the items in the order of their
   first occurence, if /:sort/ is /:from-end/, they are returned in
   reverse order of occurence, if /:sort/ is /t/, they are either sorted
   by their value, if all elems are numbers or by the number of occurences
   otherwise.
*** Examples
    #+BEGIN_SRC lisp
      (count-elements '(1 3 2 6 5 4 3 8 1 3 5 2 4 3 6 5 3 3 4 1))
      ;; => ((1 3) (2 2) (3 6) (4 3) (5 3) (6 2) (8 1))
      
      (count-elements '(1 3 2 6 5 4 3 8 1 3 5 2 4 3 6 5 3 3 4 1) :sort :from-end)
      ;; => ((8 1) (4 3) (5 3) (6 2) (2 2) (3 6) (1 3))
      
      (count-elements '(1 3 2 6 5 4 3 8 1 3 5 2 4 3 6 5 3 3 4 1) :sort t)
      ;; => ((1 3) (2 2) (3 6) (4 3) (5 3) (6 2) (8 1))
      
      (count-elements '(a b a d e c d a e d e b d f d e) :sort t)
      ;; => ((d 5) (e 4) (a 3) (b 2) (f 1) (c 1))
      
      (count-elements '((a 10) (b 11) (a 12) (d 13)) :key #'first :sort t)
      ;; => ((a 2) (d 1) (b 1))
    #+END_SRC
** counter
   Macro
   #+BEGIN_SRC lisp
     (counter start end &key (step 1) loop-p done-action)
   #+END_SRC
   Count from START to END (excluded) by STEP, optionally in loop if
   LOOP-P is T.
   
   The one-argument function DONE-ACTION is called at the end if LOOP-P is NIL.
   The function argument is the DSP node.
** cp-input-buses
   Function
   #+BEGIN_SRC lisp
     (cp-input-buses &rest optional-keywords &aux (#:lambda-list '((first-input 0 (first-bus 0) (num-channels *number-of-input-bus-channels*) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
   cp all audio inputs to buses starting at first-in-bus + bus-offset.
** cp-output-buses
   Function
   #+BEGIN_SRC lisp
     (cp-output-buses &rest optional-keywords &aux (#:lambda-list '((first-out-bus 8 id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
   cp all audio outputs to buses starting at first-out-bus.
** create-collection
   Function
   #+BEGIN_SRC lisp
     (create-collection parent width)
   #+END_SRC
** create-grid
   Function
   #+BEGIN_SRC lisp
     (create-grid parent class width)
   #+END_SRC
** create-hide-button
   Function
   #+BEGIN_SRC lisp
     (create-hide-button parent element-to-hide &key label (background '("transparent" "orange")) color flash-time values css (val 1) auto-place)
   #+END_SRC
** create-lsample
   Function
   #+BEGIN_SRC lisp
     (create-lsample file &rest args)
   #+END_SRC
   Return a lsample instance from /file/ and /args/
*** Arguments
    | =file=       | Pathname or String denoting filename.                                                                     |
    | =:path=      | List of Pathnames to search for file. Defaults to [[#sfile-path][*​​​sfile-path​​​*]].                                          |
    | =:keynum=    | Number denoting keynum of sample.                                                                         |
    | =:oneshot=   | Boolean indicationg whether not to loop the sample. Defaults to t.                                        |
    | =:loopstart= | Positive Integer denoting start of loop. Defaults to 0.                                                   |
    | =:loopend=   | Positive Integer denoting end of loop. Defaults to 0.                                                     |
    | =:amp=       | Number denoting amplitude in dB. The range [-100..0] is mapped to linear amplitude [0..1]. Defaults to 0. |

*** See also
    - [[make-lsample][make-lsample]]
** create-o-bang
   Function
   #+BEGIN_SRC lisp
     (create-o-bang parent bindings &key width height label (background '("transparent" "orange")) color flash-time css (flash t))
   #+END_SRC
** create-o-knob
   Function
   #+BEGIN_SRC lisp
     (create-o-knob parent bindings &key (unit "") (precision 2) min max width height step css)
   #+END_SRC
** create-o-multislider
   Function
   #+BEGIN_SRC lisp
     (create-o-multislider parent bindings &key (direction :up) (value 0) (min 0) (max 1) width height label background colors (thumb-color "transparent") (mapping :lin) (clip-zero nil))
   #+END_SRC
** create-o-numbox
   Function
   #+BEGIN_SRC lisp
     (create-o-numbox parent bindings &key min max width height (precision 2) css)
   #+END_SRC
** create-o-radio
   Function
   #+BEGIN_SRC lisp
     (create-o-radio parent bindings &key labels label width height (background '(("transparent" ("orange")))) color flash-time values (num 8) (direction :right) css)
   #+END_SRC
** create-o-scope
   Function
   #+BEGIN_SRC lisp
     (create-o-scope parent bindings &key width height css buffer)
   #+END_SRC
** create-o-slider
   Function
   #+BEGIN_SRC lisp
     (create-o-slider parent bindings &key (direction :up) (min 0) (max 1) label background thumb-color bar-color (mapping :lin) (clip-zero nil) (width "1em") (height "8em") padding css)
   #+END_SRC
** create-o-svg
   Function
   #+BEGIN_SRC lisp
     (create-o-svg parent bindings &key svg padding css (cursor-pos 0) (shift-x 0) (shift-y 0) (background "#fff") (scale 1) (inverse 0))
   #+END_SRC
** create-o-toggle
   Function
   #+BEGIN_SRC lisp
     (create-o-toggle parent bindings &key width height label (background '("transparent" "orange")) color flash-time values css)
   #+END_SRC
** create-o-vumeter
   Function
   #+BEGIN_SRC lisp
     (create-o-vumeter parent bindings &key (direction :up) (type :led) (mapping :db-lin) (width "1em") (height "8em") padding css)
   #+END_SRC
** ct->fr
   Function
   #+BEGIN_SRC lisp
     (ct->fr ct)
   #+END_SRC
   Return the frequency ratio of the Midicents interval /ct/.
*** Arguments
    | =ct= | The interval in Midicents. |

*** Examples
    #+BEGIN_SRC lisp
      (ct->fr 12) ;; => 2
      
      (ct->fr 1) ;; => 1.0594631
      
      (ct->fr 7) ;; => 1.4983071
      
      (ct->fr -12) ;; => 1/2
      
      (mapcar #'ct->fr (range 13))
      ;;  => (1 1.0594631 1.122462 1.1892071 1.2599211 1.3348398 1.4142135 1.4983071
      ;;      1.587401 1.6817929 1.7817974 1.8877486 2)
    #+END_SRC
*** See also
    - [[fr->ct][fr->ct]]
** cuda-dsp
   Class

   Superclass for dsp objects of the dsp infrastructure
   of /clog-dsp-widgets/ in Clamps. An object derived from this type will
   be created using the [[add-dsp][add-dsp]] function and its slots automatically
   filled on initialization.
   
   cuda-dsp implements the following slots with accessor methods of the
   same name (if not indicated otherwise) and initargs being the keywords
   of the slot symbol:
   
   =id= -- The id used in the clamps dsp infrastructure. Accessor is [[dsp-id][dsp-id]].
   
   =nodes= -- The active Incudine nodes of a running instance. Accessor is [[dsp-nodes][dsp-nodes]]
   
   =node-group= -- The Incudine group of a running instance. Defaults to 300.
   
   =unwatch= -- List of unwatch functions used by the instance.
*** Note
    Except for the /unwatch/ slot, the user normally will not be dealing
    with the slots of a cuda-dsp instance directly except for inspection
    purposes. The slots are documented here mainly for clarity and
    insight.
    
*** See also
    - [[clamps:clog-dsp-widgets][clog-dsp-widgets]]
    - [[add-dsp][add-dsp]]
* D
** date-string
   Function
   #+BEGIN_SRC lisp
     (date-string)
   #+END_SRC
   Return a string of the current time in the format
     /"yyyy-mm-dd-hr-min-sec"/
** db->amp
   Function
   #+BEGIN_SRC lisp
     (db->amp db)
   #+END_SRC
   Return amp value of dB value /db/. The dB value is clipped below -100
   and returns the amplitude 0.
*** Arguments
    | =amp= | Positive Integer denoting amplitude. |

*** Example
    #+BEGIN_SRC lisp
      (db->amp 0) ; => 1
      (db->amp -6) ; => 0.5011872
      (db->amp -100) ; => 0
    #+END_SRC
** db->db-slider
   Function
   #+BEGIN_SRC lisp
     (db->db-slider db &key (min -40) (max 12))
   #+END_SRC
** db-slider->amp
   Function
   #+BEGIN_SRC lisp
     (db-slider->amp x &key (min -40) (max 12))
   #+END_SRC
** db-slider->db
   Function
   #+BEGIN_SRC lisp
     (db-slider->db slider-val &key (min -40) (max 12))
   #+END_SRC
** def-params
   Macro
   #+BEGIN_SRC lisp
     (def-params &rest syms)
   #+END_SRC
** *​default-midi-channel​*
   :PROPERTIES:
   :CUSTOM_ID: default-midi-channel
   :END:
   Variable

   Default MIDI channel for midi controllers or access functions like
   [[ccin][ccin]].
*** See also
    - [[ccin][ccin]]
    - [[midi-controller][midi-controller]]
** *​default-midi-port​*
   :PROPERTIES:
   :CUSTOM_ID: default-midi-port
   :END:
   Variable

** define-watch
   Generic Function
   #+BEGIN_SRC lisp
     (define-watch refvar attr new)
   #+END_SRC
** defparameter*
   :PROPERTIES:
   :CUSTOM_ID: defparameter
   :END:
   Macro
   #+BEGIN_SRC lisp
     (defparameter* &rest pairs)
   #+END_SRC
   Form for the definition of multiple parameters. /Pairs/ are one or
   more elements, being the arguments of a single defparameter form.
*** Arguments
    | =pairs= | one or more elements, either a Symbol or a list of 1-3 elements with a Symbol as first and a String as third element. |

*** Examples
    #+BEGIN_SRC lisp
      (defparameter* *a* (*b*) (*c* 1) (*d* 1 "parameter d"))
      
      ;; The above form is the same as:
      
      (progn
        (defparameter *a* nil)
        (defparameter *b* nil)
        (defparameter *c* 1)
        (defparameter *d* "parameter d"))
    #+END_SRC
*** See also
    - [[#defvar][defvar​*]]
** defvar*
   :PROPERTIES:
   :CUSTOM_ID: defvar
   :END:
   Macro
   #+BEGIN_SRC lisp
     (defvar* &rest pairs)
   #+END_SRC
   Form for the definition of multiple variable. /Pairs/ are one or
   more elements, being the arguments of a single defparameter form.
*** Arguments
    | =pairs= | one or more elements, either a Symbol or a list of 1-3 elements with a Symbol as first and a String as third element. |

*** Examples
    #+BEGIN_SRC lisp
      (defvar​* *​a​* (*​b​*) (*​c​* 1) (*​d​* 1 "variable d"))
      
      ;; The above form is the same as:
      
      (progn
        (defvar *a* nil)
        (defvar *b* nil)
        (defvar *c* 1)
        (defvar *d* "variable d"))
    #+END_SRC
*** See also
    - [[#defparameter][defparameter​*]]
** delete-props
   Function
   #+BEGIN_SRC lisp
     (delete-props proplist &rest props)
   #+END_SRC
   Destructively remove props from property list /proplist/ and return
   it.
*** Arguments
    | =proplist= | Property list.                    |
    | =props=    | One or more properties to delete. |

*** See also
    - [[do-proplist][do-proplist]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-prop][get-prop]]
    - [[get-props-list][get-props-list]]
    - [[map-proplist][map-proplist]]
    - [[with-props][with-props]]
** differentiate
   Function
   #+BEGIN_SRC lisp
     (differentiate seq &key (modifier #'-) (start (elt seq 0)))
   #+END_SRC
   Return differences or the results of applying /modifier/ to subsequent
   elements of /seq/.
*** Arguments
    | =seq=       | Proper sequence to integrate.                                |
    | =:modifier= | Function to apply to all elements accumulationg the results. |
    | =:start=    | Number denoting the start value.                             |

*** Examples
    #+BEGIN_SRC lisp
      (differentiate '(0 2 3 7 12)) ; => (0 2 1 4 5)
      
      (differentiate #(0 2 3 7 12) :start 3) ; => #(3 2 1 4 5)
      
      (differentiate '(1 2 6 12 48) :modifier #'/) ; => (1 2 3 2 4)
      
      (differentiate (integrate '(17 2 4))) ; => (17 2 4)
    #+END_SRC
*** See also
    - [[integrate][integrate]]
** do-proplist
   Macro
   #+BEGIN_SRC lisp
     (do-proplist (keysym valuesym) proplist &body body)
   #+END_SRC
   Like dolist but traversing a property list. All keys and values of
   /proplist/ are bound to the symbols /keysym/ and /valuesym/ in the
   lexical scope of /body/.
*** Arguments
    | =keysym=   | Symbol bound to all keys of the property list.   |
    | =valuesym= | Symbol bound to all values of the property list. |
    | =proplist= | Property list to be traversed.                   |

*** Examples
    #+BEGIN_SRC lisp
      (do-proplist (key value) '(a 1 b 2 c 3 d 4)
        (format t "key: ~a, value: ~a~%" key value)) ;  => nil
      
      ;; Output in REPL:
      ;;
      ;; key: a, value: 1
      ;; key: b, value: 2
      ;; key: c, value: 3
      ;; key: d, value: 4
      
      (let ((proplist '(a 1 b 2 c 3 d 4)))
        (do-proplist (key value) proplist
          (setf (getf proplist key) (incf value 10)))
        proplist)
      ;; => (a 11 b 12 c 13 d 14)
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-prop][get-prop]]
    - [[get-props-list][get-props-list]]
    - [[map-proplist][map-proplist]]
    - [[with-props][with-props]]
** do-proplist/collecting
   Macro
   #+BEGIN_SRC lisp
     (do-proplist/collecting (keysym valuesym) proplist &body body)
   #+END_SRC
   Like do-proplist but collecting the result. All keys and values of
   /proplist/ are bound to the symbols /keysym/ and /valuesym/ in the
   lexical scope of /body/.
*** Arguments
    | =keysym=   | Symbol bound to all keys of the property list.   |
    | =valuesym= | Symbol bound to all values of the property list. |
    | =proplist= | Property list to be traversed.                   |

*** Examples
    #+BEGIN_SRC lisp
      (do-proplist/collecting (key val) '(:a 2 :b 5 :c 4)
        (list key (1+ val)))
      ;; => ((:a 3) (:b 6) (:c 5))
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist][do-proplist]]
    - [[get-prop][get-prop]]
    - [[get-props-list][get-props-list]]
    - [[map-proplist][map-proplist]]
    - [[with-props][with-props]]
** do-repeated
   Function
   #+BEGIN_SRC lisp
     (do-repeated n fn &rest args)
   #+END_SRC
   Recursively apply /fn/ to /args/ /n/ times.
*** Arguments
    | =n=  | Integer number of repetitions. |
    | =fn= | Function to apply.             |

*** Examples
    #+BEGIN_SRC lisp
      (do-repeated 4 (lambda (x) (* x 2)) 1) ; => 16
      
      (do-repeated 4 (lambda (x) (* x x)) 2)  ; => 65536
      
      (do-repeated 6 (lambda (list) (cons 1 list)) '()) ; => (1 1 1 1 1 1)
    #+END_SRC
*** See also
    - [[repeated][repeated]]
** dolist-db
   Macro
   #+BEGIN_SRC lisp
     (dolist-db (args list) &body body)
   #+END_SRC
   like dolist, but using destructuring-bind of args on each list element.
** dround
   Function
   #+BEGIN_SRC lisp
     (dround num &optional (prec 2))
   #+END_SRC
   Return a float of /num/ rounded to /prec/ decimal places.
*** Arguments
    | =num=  | The number to round.                                        |
    | =prec= | Non Negative Integer denoting the number of decimal places. |

*** Examples
    #+BEGIN_SRC lisp
      (dround 1/3) ; => 0.33
      
      (dround 1/3 5) ; => 0.33333
      
      (dround 1) ; => 1.0
    #+END_SRC
** dsp-id
   Generic Function
   #+BEGIN_SRC lisp
     (dsp-id object)
   #+END_SRC
   Accessor for the id slot of dsp /object/. Read-only.
*** See also
    - [[cuda-dsp][cuda-dsp]]
** dsp-nodes
   Generic Function
   #+BEGIN_SRC lisp
     (dsp-nodes object)
   #+END_SRC
   Accessor for the nodes slot of dsp /object/.
*** See also
    - [[cuda-dsp][cuda-dsp]]
* E
** ensure-buffer
   Function
   #+BEGIN_SRC lisp
     (ensure-buffer file &key (path *sfile-path*))
   #+END_SRC
   Load and register buffer from /file/ if not loaded already. Return
   buffer. /file/ will be searched recursively in all directories of
   [[#sfile-path][*​​sfile-path​​*]].
*** Arguments
    | =file=  | Pathname or String denoting a soundfile.         |
    | =:path= | List of Pathnames or Strings to search for file. |

*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[add-buffer][add-buffer]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-id][buffer-id]]
    - [[find-buffer][find-buffer]]
    - [[buffer-name][buffer-name]]
    - [[bufname=][bufname=]]
    - [[list-buffers][list-buffers]]
    - [[remove-buffer][remove-buffer]]
    - [[remove-all-buffers][remove-all-buffers]]
    - [[#sfile-path][*​​sfile-path​​*]]
** ensure-prop
   Macro
   #+BEGIN_SRC lisp
     (ensure-prop proplist prop default)
   #+END_SRC
   Ensure that the property /prop/ exists in /proplist/, otherwise set it
   to /default/. Return the value of prop.
*** Arguments
    | =proplist= | Property list.                                            |
    | =prop=     | Keyword or Symbol denoting the property key to ensure.    |
    | =default=  | The value the property should get assigned to if not set. |

*** Examples
    #+BEGIN_SRC lisp
      (defvar *proplist* '(:a 10 :b hello :c "world"))
      
      (ensure-prop *proplist* :d 5)
      ;; => 5
      
      *proplist* ; => (:d 5 :a 10 :b hello :c "world")
      
      ;; As property :a already exists, don't change it and return its
      ;; current value:
      
      (ensure-prop *proplist* :a 3)
      ;; => 10
      
      *proplist* ; => (:d 5 :a 10 :b hello :c "world")
    #+END_SRC
** ensure-sfz-preset
   Function
   #+BEGIN_SRC lisp
     (ensure-sfz-preset preset &key force oneshot)
   #+END_SRC
   Load the sfz definition of /preset/ and all its samples into the
   system if it hasn't been loaded previously. If force is /t/, force
   reload. Optionally disable loop playback with /oneshot/.
   
   The association between the preset name and its sfz file has to be
   established before using [[add-sfz-preset][add-sfz-preset]], otherwise a warning is
   issued and no file is loaded.
*** Arguments
    | =preset=   | A keynum or symbol to serve as the name/id of the preset.                         |
    | =:force=   | A boolean indicating to force a reload even if the preset has been loaded before. |
    | =:oneshot= | Boolean denoting whether not to loop the playback.                                |

*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
    - [[load-sfz-preset][load-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
    - [[sfz][sfz]]
    - [[sfz-get-range][sfz-get-range]]
    - [[sfz-preset-file][sfz-preset-file]]
    - [[sfz-preset-lsamples][sfz-preset-lsamples]]
    - [[sfz-preset-buffers][sfz-preset-buffers]]
    - [[sfz-preset-loaded?][sfz-preset-loaded?]]
** *​env1​*
   :PROPERTIES:
   :CUSTOM_ID: env1
   :END:
   Variable

   Incudine three point ASR envelope with attack time 0 and release time
   0.1 of the total duration.
*** Example
      #+BEGIN_SRC lisp
      (plot *env1*)
      ;; => nil
      #+END_SRC
      #+attr_html: :width 50%
      #+CAPTION: *​env1​* envelope
      [[./img/env1-plot.svg]]
** envelope*
   :PROPERTIES:
   :CUSTOM_ID: envelope
   :END:
   Incudine VUG
   #+BEGIN_SRC lisp
     (envelope* (env envelope) (gate sample) (time-scale sample) (done-action function))
   #+END_SRC
   Envelope Ugen working with any blocksize. The product of /time-scale/
   and the total duration of /env/ is the total duration of the envelope
   in seconds. /done-action/ is called when the total-duration has been
   reached or when /gate/ is zero and the release phase of the envelope
   has ended.
   
   envelope* returns an array of block-size samples.
*** Arguments
    | =env=         | incudine.vug:envelope instance to use.                          |
    | =gate=        | Number functioning as a gate: If zero, start the release phase. |
    | =time-scale=  | Number scaling the envelope x-values.                           |
    | =done-action= | Function to call on the dsp-node at end of release.             |

*** See also
    - [[#buffer-loop-play][buffer-loop-play​*]]
    - [[#buffer-play][buffer-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#line][line​*]]
    - [[#phasor][phasor​*]]
    - [[#phasor-loop][phasor-loop​*]]
    - [[#play-buffer][play-buffer​*]]
    - [[#play-buffer-loop][play-buffer-loop​*]]
    - [[#play-buffer-stretch][play-buffer-stretch​*]]
    - [[#play-buffer-stretch-env-pan-out][play-buffer-stretch-env-pan-out​*]]
** every-nth
   Function
   #+BEGIN_SRC lisp
     (every-nth list n &key (offset 0))
   #+END_SRC
   Return a sublist of /list/ containing every element with an index
   being a multiple of /n/.
*** Arguments
    | =list=    | Input list.                                                    |
    | =n=       | Positive integer denoting the index distance between elements. |
    | =:offset= | Positive integer denoting offset into the input list.          |

*** Example
    #+BEGIN_SRC lisp
      (every-nth '(9 10 11 12 13 14 15 16 17 18 19 20) 3 :offset 1)
      ;; => (10 13 16 19)
    #+END_SRC
** evt-amp
   Function
   #+BEGIN_SRC lisp
     (evt-amp obj)
   #+END_SRC
   Return the amplitude of CM /obj/.
*** Arguments
    | =obj= | Instance of a Common Music event |

*** Example
    #+BEGIN_SRC lisp
      (evt-amp (new midi)) ; => 0.5
    #+END_SRC
*** See also
    - [[evt-duration][evt-duration]]
    - [[evt-keynum][evt-keynum]]
    - [[evt-time][evt-time]]
** evt-duration
   Function
   #+BEGIN_SRC lisp
     (evt-duration obj)
   #+END_SRC
   Return the duration of CM /obj/.
*** Arguments
    | =obj= | Instance of a Common Music event |

*** Example
    #+BEGIN_SRC lisp
      (evt-duration (new midi)) ; => 0.5
    #+END_SRC
*** See also
    - [[evt-keynum][evt-keynum]]
    - [[evt-time][evt-time]]
    - [[evt-amp][evt-amp]]
** evt-keynum
   Function
   #+BEGIN_SRC lisp
     (evt-keynum obj)
   #+END_SRC
   Return the keynum of CM /obj/.
*** Arguments
    | =obj= | Instance of a Common Music event |

*** Example
    #+BEGIN_SRC lisp
      (evt-keynum (new midi)) ; => 60
    #+END_SRC
*** See also
    - [[evt-amp][evt-amp]]
    - [[evt-duration][evt-duration]]
    - [[evt-time][evt-time]]
** evt-time
   Function
   #+BEGIN_SRC lisp
     (evt-time obj)
   #+END_SRC
   Return the time of CM /obj/.
*** Arguments
    | =obj= | Instance of a Common Music event |

*** Example
    #+BEGIN_SRC lisp
      (evt-time (new sfz :time 3)) ; => 3
    #+END_SRC
*** See also
    - [[evt-amp][evt-amp]]
    - [[evt-duration][evt-duration]]
    - [[evt-keynum][evt-keynum]]
** exp-n
   Macro
   #+BEGIN_SRC lisp
     (exp-n val min max)
   #+END_SRC
   Return the reverse exponential interpolation for a value in the range
   /[min..max]/ as a normalized float value. /Min/ and /max/ have to be
   positive numbers.
*** Arguments
    | =x=   | An input value in the range /[min..max]/ to be interpolated. |
    | =min= | The minimum value.                                           |
    | =max= | The maximum value.                                           |

*** Examples
    #+BEGIN_SRC lisp
      (exp-n 1 1 100) ; => 0.0
      
      (exp-n 10 1 100) ; => 0.5
      
      (exp-n 100 1 100) ; => 1.0
    #+END_SRC
*** See also
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** export-svg
   Function
   #+BEGIN_SRC lisp
     (export-svg svg-file)
   #+END_SRC
** export-svg-file
   Function
   #+BEGIN_SRC lisp
     (export-svg-file svg-file &key (fname "/tmp/test.svg" fname-supplied-p) (inverse nil) (showgrid t) (gridtype "4x4") width (zoom 1.4) (cx 350) (cy 360) (w-width 1920) (w-height 1080) (w-x 0) (w-y 0))
   #+END_SRC
* F
** faderfox-gui
   Function
   #+BEGIN_SRC lisp
     (faderfox-gui #:id gui-parent &key (chan 4))
   #+END_SRC
** faderfox-midi
   Class

** fibonacci
   Function
   #+BEGIN_SRC lisp
     (fibonacci n)
   #+END_SRC
   Calculate the /n/-th element of the Fibonacci series. The function is
   not recursive, but calculates the value directly, running in constant
   time.
*** Arguments
    | =n= | Non Negative Integer denoting the index of the Fibonacci series. |

*** Example
    #+BEGIN_SRC lisp
      (mapcar #'fibonacci (range 12)) ; => (1 1 2 3 5 8 13 21 34 55 89 144)
    #+END_SRC
** file-string
   Function
   #+BEGIN_SRC lisp
     (file-string infile)
   #+END_SRC
** filter
   Function
   #+BEGIN_SRC lisp
     (filter pred seq)
   #+END_SRC
   Return a list of all elements of /seq/ satisfying /pred/.
*** Arguments
    | =seq=  | A Common Lisp sequence                          |
    | =pred= | Function of one element for filtering elements. |

*** Example
    #+BEGIN_SRC lisp
      (filter (lambda (e) (< e 9)) '(3 1 12 17 5 4)) ; => (3 1 5 4)
    #+END_SRC
** find-buffer
   Function
   #+BEGIN_SRC lisp
     (find-buffer ref)
   #+END_SRC
   Return registered buffer with /ref/ either being a full pathname, the
   pathname-name, an integer id or a buffer.
*** Arguments
    | =ref= | Integer denoting id of buffer or String or Pathname denoting the buffer's filename or a buffer. |

*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[add-buffer][add-buffer]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-id][buffer-id]]
    - [[buffer-name][buffer-name]]
    - [[bufname=][bufname=]]
    - [[clamps-buffer-load][clamps-buffer-load]]
    - [[list-buffers][list-buffers]]
    - [[remove-buffer][remove-buffer]]
    - [[remove-all-buffers][remove-all-buffers]]
** find-controller
   Function
   #+BEGIN_SRC lisp
     (find-controller #:id)
   #+END_SRC
   Return MIDI controller instance with ID /id/ or /nil/ if not
   registered.
*** Arguments
    | =id= | Keyword or Symbol used as ID of a midicontroller instance . |

*** See also
    - [[add-midi-controller][add-midi-controller]]
    - [[list-midi-controllers][list-midi-controllers]]
    - [[midi-controller][midi-controller]]
    - [[remove-midi-controller][remove-midi-controller]]
    - [[remove-all-midi-controllers][remove-all-midi-controllers]]
** find-dsp
   Function
   #+BEGIN_SRC lisp
     (find-dsp id)
   #+END_SRC
   Find a running Incudine dsp registered with [[add-dsp][add-dsp]].
*** Arguments
    | =id= | Keyword or Symbol identifying the dsp. |

*** See also
    - [[add-dsp][add-dsp]]
    - [[list-dsps][list-dsps]]
    - [[remove-dsp][remove-dsp]]
** find-midi-port
   Function
   #+BEGIN_SRC lisp
     (find-midi-port #:id)
   #+END_SRC
   Return a registered midi port denoted by /id/.
*** Arguments
    | =id= | Keyword or Symbol denoting the id of the midi port. |

*** See also
    - [[close-midi-port][close-midi-port]]
    - [[list-midi-ports][list-midi-ports]]
    - [[open-midi-port][open-midi-port]]
** flash
   Generic Function
   #+BEGIN_SRC lisp
     (flash clog-obj)
   #+END_SRC
** flatten
   Function
   #+BEGIN_SRC lisp
     (flatten form)
   #+END_SRC
   Remove all brackets except the outmost from /form/. Non-recursive,
   non-stack version from Rosetta Code.
*** Arguments
    | =form= | A Common Lisp form. |

*** Examples
    #+BEGIN_SRC lisp
      (flatten '((a b) (((c d) (e f)) (g h)) (i k)))
      ;; -> (a b c d e f g h i k)
    #+END_SRC
*** See also
    - [[flatten-fn][flatten-fn]]
** flatten-fn
   Function
   #+BEGIN_SRC lisp
     (flatten-fn list &key (test #'atom) (key #'identity))
   #+END_SRC
   Remove all brackets except the outmost in /list/. Use /test/ and /key/
   to determine where to stop removing brackets.
*** Arguments
    | =list= | input List.                                                                 |
    | =test= | Function applied to each element of list to test for the end of flattening. |
    | =key=  | Function applied to each element of list before testing.                    |

*** Examples
    #+BEGIN_SRC lisp
      (flatten-fn '((a b) (((c d) (e f)) (g h)) (i k)))
      ;; -> (a b c d e f g h i k)
      
      ;; keep one level of brackets:
      
      (flatten-fn '((a b) (((c d) (e f)) (g h)) (i k)) :key #'car)
      ;; -> ((a b) (c d) (e f) (g h) (i k))
    #+END_SRC
*** See also
    - [[flatten][flatten]]
** format-with-slots
   Macro
   #+BEGIN_SRC lisp
     (format-with-slots stream obj string &rest slots)
   #+END_SRC
** fr->ct
   Function
   #+BEGIN_SRC lisp
     (fr->ct fr)
   #+END_SRC
   Return the Midicents interval of the frequency ratio /fr/.
*** Arguments
    | =fr= | Positive Number denoting the frequency ratio of the interval. |

*** Examples
    #+BEGIN_SRC lisp
      (fr->ct 2) ;; => 12.0
      
      (fr->ct 4/5) ;; => -3.863137
      
      (fr->ct 3/2) ;; => 7.01955
      
      (fr->ct 1/2) ;; => -12.0
      
      (mapcar #'fr->ct (range 1 17))
      ;; => (0.0 12.0 19.01955 24.0 27.863136 31.01955 33.68826 36.0 38.0391 39.863136
      ;;     41.51318 43.01955 44.405277 45.68826 46.882687 48.0)
    #+END_SRC
*** See also
    - [[ct->fr][ct->fr]]
** ftom
   Function
   #+BEGIN_SRC lisp
     (ftom f &key (tuning-base 440))
   #+END_SRC
* G
** get-dtime-fn
   Function
   #+BEGIN_SRC lisp
     (get-dtime-fn mina maxa minbfn maxbfn &key (distribution '((0 :weight 9 (1 :weight 3) 2 3 4))) (thresh 0.5))
   #+END_SRC
   return a function calculating a delta-time on each call. The
   distribution specifies a random distribution (using cm's weighting) to
   determine the number of dtimes returned between [mina..maxa] before
   returning a number between calling [minbfn..maxbfn] on x. A :thresh
   keyword determines a threshold for [minb..maxb], below which no
   [mina..maxa] values are returned.
** get-dtime-fn-no-x
   Function
   #+BEGIN_SRC lisp
     (get-dtime-fn-no-x mina maxa minb maxb &key (distribution '(1 1 1 1 2 3 4)))
   #+END_SRC
   return a function calculating a delta-time on each call. The
   distribution specifies a random distribution (using cm's weighting) to
   determine the number of dtimes returned between [mina..maxa] before
   returning a number between [minb..maxb].
** get-duplicates
   Function
   #+BEGIN_SRC lisp
     (get-duplicates list &key (test #'eql) (once nil))
   #+END_SRC
   Return all Elements of /list/ which occur more than once with respect
   to the /test/ predicate. If /once/ is non-nil, return each duplicate
   element only once.
*** Arguments
    | =list= | List being examined.                                                    |
    | =test= | Function to determine equality of elements.                             |
    | =once= | Boolean to determine if only one of the duplicate elements is returned. |

*** Examples
    #+BEGIN_SRC lisp
      (get-duplicates '(0 1 3 2 4 3 9 3 1 3 4 2 3)) ; => (1 3 2 4 3 3 3)
      
      (get-duplicates '(0 1 3 2 4 3 9 3 1 3 4 2 3) :once t)  ; => (1 2 4 3)
    #+END_SRC
** get-keynum
   Function
   #+BEGIN_SRC lisp
     (get-keynum entry)
   #+END_SRC
** get-prop
   Function
   #+BEGIN_SRC lisp
     (get-prop proplist key &optional default)
   #+END_SRC
   Like getf but using #'equal for testing of the property key.
*** Arguments
    | =proplist= | Property list                               |
    | =key=      | Lisp Object ervong as key in property list. |

*** Example
    #+BEGIN_SRC lisp
      (get-prop '("George" "Maciunas" "Simone" "de Beauvoir") "Simone") ; => "de Beauvoir"
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist][do-proplist]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-props-list][get-props-list]]
    - [[map-proplist][map-proplist]]
    - [[with-props][with-props]]
** get-props-list
   Function
   #+BEGIN_SRC lisp
     (get-props-list proplist props &key (force-all nil))
   #+END_SRC
   Return a new property list containing /props/ and their values
   extracted from /proplist/. Properties not present in proplist are
   ignored. If /force-all/ is non-nil, also return properties not present
   in proplist with nil as value.
*** Arguments
    | =proplist=   | Property list.                                                          |
    | =props=      | Properties to extract from proplist.                                    |
    | =:force-all= | Boolean to indicate if non-present props should get included in result. |

*** Examples
    #+BEGIN_SRC lisp
      (get-props-list '(:a 1 :b 2 :c 3 :d "Foo") '(:d :a)) ; => (:d "Foo" :a 1)
      
      (get-props-list '(:a 1 :b 2 :c 3 :d "Foo") '(:a :e)) ; => (:a 1)
      
      (get-props-list '(:a 1 :b 2 :c 3 :d "Foo" :a 4) '(:a :e) :force-all t)  ; => (:a 1 :e nil)
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist][do-proplist]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-prop][get-prop]]
    - [[map-proplist][map-proplist]]
    - [[with-props][with-props]]
** get-ref
   Function
   #+BEGIN_SRC lisp
     (get-ref controller ref-idx)
   #+END_SRC
   Return the ref-object of the midi-controller /controller/ given the
   /ref-idx/ indexing into the cc-nums slot of the controller.
*** Arguments
    | =controller= | Instance of type midi-controller.                                               |
    | =ref-idx=    | Non Negative Integer denoting the index of the cc-nums array of the controller. |

** get-sfz-preset
   Function
   #+BEGIN_SRC lisp
     (get-sfz-preset preset &key force oneshot)
   #+END_SRC
   Load the sfz definition of /preset/ and all its samples into the
   system if it hasn't been loaded previously. If force is /t/, force
   reload. Optionally disable loop playback with /oneshot/.
   
   The association between the preset name and its sfz file has to be
   established before using [[add-sfz-preset][add-sfz-preset]], otherwise a warning is
   issued and no file is loaded.
*** Arguments
    | =preset=   | A keynum or symbol to serve as the name/id of the preset.                         |
    | =:force=   | A boolean indicating to force a reload even if the preset has been loaded before. |
    | =:oneshot= | Boolean denoting whether not to loop the playback.                                |

*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
    - [[load-sfz-preset][load-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
    - [[sfz][sfz]]
    - [[sfz-get-range][sfz-get-range]]
    - [[sfz-preset-file][sfz-preset-file]]
    - [[sfz-preset-lsamples][sfz-preset-lsamples]]
    - [[sfz-preset-buffers][sfz-preset-buffers]]
    - [[sfz-preset-loaded?][sfz-preset-loaded?]]
** get-time
   Function
   #+BEGIN_SRC lisp
     (get-time secs &key (prec 2))
   #+END_SRC
   Convert a /secs/ representing seconds into a list of the form /(hr min
   secs)/.
*** Arguments
    | =secs= | Number representing time in seconds.        |
    | =prec= | Number of digits after the comma of seconds |

*** Example
    #+BEGIN_SRC lisp
      (get-time 2753.3) ; => (0 45 53.30005)
    #+END_SRC
** get-val
   Function
   #+BEGIN_SRC lisp
     (get-val ref)
   #+END_SRC
   Return the value of /ref/.
*** Arguments
    | =ref= | An instance of [[ref-object][ref-object]]. |

*** See also
    - [[bang-object][bang-object]]
    - [[make-computed][make-computed]]
    - [[make-ref][make-ref]]
    - [[ref-object][ref-object]]
    - [[set-val][set-val]]
    - [[watch][watch]]
** *​global-midi-channel​*
   :PROPERTIES:
   :CUSTOM_ID: global-midi-channel
   :END:
   Variable

   Default MIDI channel for midi controllers or access functions like
   [[ccin][ccin]].
*** See also
    - [[ccin][ccin]]
    - [[midi-controller][midi-controller]]
** *​gnuplot-header​*
   :PROPERTIES:
   :CUSTOM_ID: gnuplot-header
   :END:
   Variable

** *​gnuplot-options​*
   :PROPERTIES:
   :CUSTOM_ID: gnuplot-options
   :END:
   Variable

** *​gnuplot-program​*
   :PROPERTIES:
   :CUSTOM_ID: gnuplot-program
   :END:
   Variable

** group
   Function
   #+BEGIN_SRC lisp
     (group source n)
   #+END_SRC
   group elems of list into sublists of length n
** group-by
   Function
   #+BEGIN_SRC lisp
     (group-by list group-lengths)
   #+END_SRC
   Partition /list/ into sublists of lengths given by /group-lenghts/
   cyclically.
*** Arguments
    | =list=          | The list to partition.                                                        |
    | =group-lenghts= | List of Positive Integers denoting the sequence of lengths of the partitions. |

*** Example
    #+BEGIN_SRC lisp
      (group-by '(1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6) '(2 3 5))
      ;; => ((1 2) (3 4 5) (6 7 8 9 1) (2 3) (4 5 6) (7 8 9 1 2) (3 4) (5 6))
    #+END_SRC
** group-by-key
   Function
   #+BEGIN_SRC lisp
     (group-by-key source &key (test #'=) (key #'car))
   #+END_SRC
   Group elems of /source/ into sublists depending on /test/ and
   /key/. Source has to be sorted according to test!
** gui
   Function
   #+BEGIN_SRC lisp
     (gui)
   #+END_SRC
   Open the page at /<clamps-base-url>/ in a Browser.
*** See also
    - [[clamps-base-url][clamps-base-url]]
    - [[meters][meters]]
* H
** handle-midi-in
   Generic Function
   #+BEGIN_SRC lisp
     (handle-midi-in instance opcode d1 d2)
   #+END_SRC
** handle-preset-button-press
   Function
   #+BEGIN_SRC lisp
     (handle-preset-button-press instance button-idx)
   #+END_SRC
   Handling of button press of s-buttons and m-buttons: Depending on the
   state of tr-rec, recall, store or copy a preset.
** *​hanning1024​*
   :PROPERTIES:
   :CUSTOM_ID: hanning1024
   :END:
   Variable

   Incudine buffer of length 1024 containing a Hanning window.
*** Example
      #+BEGIN_SRC lisp
      (plot *hanning1024*)
      ;; => #<incudine:buffer :FRAMES 1024 :CHANNELS 1 :SR 44100.0>
      #+END_SRC
      
      #+attr_html: :width 50%
      #+CAPTION: *​hanning1024​* buffer
      [[./img/hanning-plot.svg]]
*** See also
    - [[#sine1024][*​​sine1024​​*]]
** hash-table-contents
   Function
   #+BEGIN_SRC lisp
     (hash-table-contents hash-table)
   #+END_SRC
   Return all key/value pairs of /hash-table/ in a list.
** highlight
   Generic Function
   #+BEGIN_SRC lisp
     (highlight clog-element value)
   #+END_SRC
* I-J
** idump
   Function
   #+BEGIN_SRC lisp
     (idump &optional (node 0))
   #+END_SRC
   Dump all active dsps of /node/ to the /incudine:*​​logger-stream​​*/
   output.
*** Arguments
    | =node= | Either a Non Negative Integer denoting the id of the node or an /incudine:node/ Instance. |

*** Note
    If calling idump doesn't produce any output although dsps are running,
    reset the logger-stream using [[reset-logger-stream][reset-logger-stream]].
** *​in-refs​*
   :PROPERTIES:
   :CUSTOM_ID: in-refs
   :END:
   Variable

** index-list
   Function
   #+BEGIN_SRC lisp
     (index-list list &key (n 0))
   #+END_SRC
   Return /list/ with increasing indexes consed to the front of each
   element of list starting from /n/.
*** Arguments
    | =list= | List containing elements which get prepended indices. |
    | =n=    | Integer denoting starting index                       |

*** Example
    #+BEGIN_SRC lisp
      (index-list '(a b c d e)) ; => ((0 . a) (1 . b) (2 . c) (3 . d) (4 . e))
    #+END_SRC
** input-bus
   Function
   #+BEGIN_SRC lisp
     (input-bus channel)
   #+END_SRC
** input-cu-osc-stream
   Structure

** input-cu-osc-stream-receiver
   Function
   #+BEGIN_SRC lisp
     (input-cu-osc-stream-receiver instance)
   #+END_SRC
** input-stream
   Structure

** input-stream-p
   Function
   #+BEGIN_SRC lisp
     (input-stream-p object)
   #+END_SRC
** integrate
   Function
   #+BEGIN_SRC lisp
     (integrate seq &key (modifier #'+) (start (elt seq 0)))
   #+END_SRC
   Return a running sum (or any other /modifier/ function) of /seq/.
*** Arguments
    | =seq=       | Proper sequence to integrate.                                |
    | =:modifier= | Function to apply to all elements accumulationg the results. |
    | =:start=    | Number denoting the start value.                             |

*** Examples
    #+BEGIN_SRC lisp
      (integrate '(0 2 1 4 5)) ; => (0 2 3 7 12)
      
      (integrate '(0 2 1 4 5) :start 10) ; => (10 12 13 17 22)
      
      (integrate '(1 2 3 2 4) :modifier #'*) ; => (1 2 6 12 48)
      
      (integrate '(1 2 3 2 4) :modifier #'*) ; => (1 2 6 12 48)
    #+END_SRC
*** See also
    - [[differentiate][differentiate]]
* K
** keynum->hz
   Function
   #+BEGIN_SRC lisp
     (keynum->hz keynum)
   #+END_SRC
   Convert VALUE dB to linear value.
* L
** let-default
   Macro
   #+BEGIN_SRC lisp
     (let-default ((sym test default)) &body body)
   #+END_SRC
** levelmeter
   Class

** levelmeter-full-gui
   Function
   #+BEGIN_SRC lisp
     (levelmeter-full-gui id gui-parent &key (#:group 300) (type :bus) refs (num 1) (audio-bus 0))
   #+END_SRC
** levelmeter-gui
   Function
   #+BEGIN_SRC lisp
     (levelmeter-gui id gui-parent &key (#:group 300) (type :bus) refs (num 1) (audio-bus 0))
   #+END_SRC
** lin-n
   Function
   #+BEGIN_SRC lisp
     (lin-n val min max)
   #+END_SRC
   Return the reverse linear interpolation for a value in the range
   /[min..max]/ as a normalized float value.
*** Arguments
    | =x=   | An input value in the range /[min..max]/ to be interpolated. |
    | =min= | The minimum value.                                           |
    | =max= | The maximum value.                                           |

*** Examples
    #+BEGIN_SRC lisp
      (lin-n 10 10 20) ; => 0.0
      
      (lin-n 15 10 20) ; => 0.5
      
      (lin-n 20 10 20) ; => 1.0
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** line*
   :PROPERTIES:
   :CUSTOM_ID: line
   :END:
   Incudine VUG
   #+BEGIN_SRC lisp
     (line* (start sample) (end sample) (duration sample) (done-action function))
   #+END_SRC
   Ugen of a line working with any block size.
*** Arguments
    | =start=    | Number denoting start value.         |
    | =end=      | Number denoting end value-           |
    | =duration= | Number denoting duration in seconds. |

*** See also
    - [[#buffer-loop-play][buffer-loop-play​*]]
    - [[#buffer-play][buffer-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#phasor][phasor​*]]
    - [[#phasor-loop][phasor-loop​*]]
    - [[#play-buffer][play-buffer​*]]
    - [[#play-buffer-loop][play-buffer-loop​*]]
    - [[#play-buffer-stretch][play-buffer-stretch​*]]
    - [[#play-buffer-stretch-env-pan-out][play-buffer-stretch-env-pan-out​*]]
** lines->svg
   Function
   #+BEGIN_SRC lisp
     (lines->svg list svg-file &key color opacity (stroke-width 0.5))
   #+END_SRC
** list-buffers
   Function
   #+BEGIN_SRC lisp
     (list-buffers)
   #+END_SRC
   Return a list /(buffer-id buffer-name buffer)/ for each entry in
   the clamps buffer registry.
*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[add-buffer][add-buffer]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-id][buffer-id]]
    - [[buffer-name][buffer-name]]
    - [[bufname=][bufname=]]
    - [[clamps-buffer-load][clamps-buffer-load]]
    - [[find-buffer][find-buffer]]
    - [[remove-buffer][remove-buffer]]
    - [[remove-all-buffers][remove-all-buffers]]
** list-dsps
   Function
   #+BEGIN_SRC lisp
     (list-dsps)
   #+END_SRC
   Return all running Incudine dsps registered with [[add-dsp][add-dsp]] in a
   list sorted by ID.
*** See also
    - [[add-dsp][add-dsp]]
    - [[find-dsp][find-dsp]]
    - [[remove-dsp][remove-dsp]]
** list-midi-controllers
   Function
   #+BEGIN_SRC lisp
     (list-midi-controllers)
   #+END_SRC
   Return the IDs of all registered midi controllers in a list.
*** See also
    - [[add-midi-controller][add-midi-controller]]
    - [[find-controller][find-controller]]
    - [[midi-controller][midi-controller]]
    - [[remove-midi-controller][remove-midi-controller]]
    - [[remove-all-midi-controllers][remove-all-midi-controllers]]
** list-midi-ports
   Function
   #+BEGIN_SRC lisp
     (list-midi-ports &key (sort t))
   #+END_SRC
   Return a list of the ids of all registered Midi Ports. If /sort/ is
   non-nilc, return a sorted list of the ids, otherwise return the ids in
   the reverse order of their instantiation.
*** Arguments
    | =:sort= | Boolean denoting sort order of the ids. Defaults to t. |

*** See also
    - [[close-midi-port][close-midi-port]]
    - [[find-midi-port][find-midi-port]]
    - [[open-midi-port][open-midi-port]]
** list-sfz-presets
   Function
   #+BEGIN_SRC lisp
     (list-sfz-presets &key (loaded nil))
   #+END_SRC
   Return a sorted list of all sfz preset names.
*** Arguments
    | =:loaded= | Boolean to indicate whether only the preset names of loaded presets should be returned. If /nil/ all registered preset names are returned. |

** load-ats
   Function
   #+BEGIN_SRC lisp
     (load-ats file &key (dist-energy t))
   #+END_SRC
   Load and return an ATS sound from /file/. Optionally move the energy
   from the noise bands into the partials. /file/ will be searched
   recursively in all directories of [[#ats-file-path][*​​ats-file-path​​*]].
*** Arguments
    | =file=         | String denoting the filename of a soundfile.                                                                 |
    | =:dist-energy= | Boolean indicating whether to to transfer the noise from the boise-bands to the dist-energy in the partials. |

*** See also
    - [[clamps:ats-cuda-display][ats-cuda-display]]
    - [[#ats-file-path][*​​ats-file-path​​*]]
    - [[ats-sound][ats-sound]]
    - [[save-ats][save-ats]]
    - [[track-ats][track-ats]]
** load-sfz-preset
   Function
   #+BEGIN_SRC lisp
     (load-sfz-preset file name &key force oneshot)
   #+END_SRC
   Load a sfz /file/ into a preset with the id name. In case this preset
   already exists, the old one will only be overwritten if force is set
   to t. This function normally doesn't need to be called
   explicitely. The preferred mechanism to deal with sfz presets is by
   using a combination of [[add-sfz-preset][add-sfz-preset]] and [[ensure-sfz-preset][ensure-sfz-preset]].
   /file/ will be searched recursively in all directories of
   [[#sfz-file-path][*​​sfz-file-path​​*]].
*** Arguments
    | =file=     | Path or filename of the sfz file to load                                   |
    | =name=     | symbol to identify the preset (preferably a keyword, but any symbol works) |
    | =:force=   | Force loading of the preset even if it already exists.                     |
    | =:oneshot= | Boolean denoting whether not to loop the playback.                         |

*** Examples
    #+BEGIN_SRC lisp
      (load-sfz-preset "~/quicklisp/local-projects/clamps/packages/cl-sfz/snd/sfz/Flute-nv/000_Flute-nv.sfz" :flute-nv)
    #+END_SRC
*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
    - [[sfz][sfz]]
    - [[sfz-get-range][sfz-get-range]]
    - [[sfz-preset-file][sfz-preset-file]]
    - [[sfz-preset-loaded?][sfz-preset-loaded?]]
    - [[#sfz-file-path][*​​sfz-file-path​​*]]
** load-sounds-from-dir
   Function
   #+BEGIN_SRC lisp
     (load-sounds-from-dir dir &key (filter "*.wav"))
   #+END_SRC
   Load all soundfiles in /dir/ into clamps buffers in case they don't
   exist already in the registry and return the buffer-ids of all newly
   loaded files in a list.
*** Arguments
    | =dir=     | Pathname or String designing a pathname                  |
    | =:filter= | String designing a filename pattern. Defaults to "*.wav" |

*** See also
    - [[clamps-buffer-load][clamps-buffer-load]]
    - [[buffer-id][buffer-id]]
** lsample
   Structure

   Structure for a sample with two loop-points.
*** Note
    Normally the user shouldn't be dealing with a lsample struct
    directly. It is used by the /sfz/ and /poolevent/ classes and
    documented here for completeness and insight.
    
    A lsample contains the following slots, accessible using the functions
    /lsample-<slot-name>/:
    
    =name= -- Filename of the sample source.
    
    =buffer= -- Buffer of the sample data.
    
    =oneshot= -- Boolean indicating whether not to loop the sample on playback.
    
    =keynum= -- Double Float denoting original keynum of the recorded sample.
    
    =loopstart= -- Double Float denoting the loop start for loop playback, defaulting to /+​sample-zero​+/.
    
    =loopend= -- Double Float denoting the loop start for loop playback, defaulting to /+​sample-zero​+/.
    
    =amp= -- Amplitude of recorded sample in dB, defaulting to /+​sample-zero​+/.
    
*** See also
    - [[sfz][sfz]]
** lsample-dur
   Function
   #+BEGIN_SRC lisp
     (lsample-dur lsample)
   #+END_SRC
   Return duration of /lsample/ in seconds.
*** Arguments
    | =lsample= | Lsample Struct |

*** See also
    - [[lsample][lsample]]
    - [[lsample-pathname][lsample-pathname]]
** lsample-pathname
   Function
   #+BEGIN_SRC lisp
     (lsample-pathname lsample)
   #+END_SRC
   Return the full pathname of /lsample/.
*** Arguments
    | =lsample= | Instance of type lsample. |

*** See also
    - [[lsample][lsample]]
    - [[lsample-dur][lsample-dur]]
* M
** m-controller
   Generic Function
   #+BEGIN_SRC lisp
     (m-controller object)
   #+END_SRC
   Accessor method for the /midi-controller/ slot of a [[clog-midi-controller][clog-midi-controller]] instance.
*** See also
    - [[clog-midi-controller][clog-midi-controller]]
** m-exp
   Function
   #+BEGIN_SRC lisp
     (m-exp x min max)
   #+END_SRC
   Return the exponential interpolation for a MIDI value in the range
   /[min..max]/ as a float value. The min and max values have to be
   positive.
*** Arguments
    | =x=   | An input value in the range /[0..127]/ to be interpolated. |
    | =min= | The output value for /x = 0/.                              |
    | =max= | The output value for /x = 127/.                            |

*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (m-exp 0 1 100) ; => 1.0 (100.0%)
      
      (m-exp 64 1 100) ; => 10.18296
      
      (m-exp 127 1 100) ; => 100.0
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** m-exp-dev
   Function
   #+BEGIN_SRC lisp
     (m-exp-dev x max)
   #+END_SRC
   return a random deviation factor, the deviation being exponentially
   interpolated between 1 for x=0 and [1/max..max] for x=127.
** m-exp-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-fn min max)
   #+END_SRC
   exp interpolation for midivalues (x = [0..127])
** m-exp-rd-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-rd-fn min max)
   #+END_SRC
   rounded exp interpolation for midivalues (x = [0..127])
** m-exp-rd-rev-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-rd-rev-fn min max)
   #+END_SRC
** m-exp-rev-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-rev-fn min max)
   #+END_SRC
   exp reverse interpolation fn for midivalues (x = [0..127])
** m-exp-zero
   Function
   #+BEGIN_SRC lisp
     (m-exp-zero x min max)
   #+END_SRC
   exp interpolation for midivalues (x = [0..127]) with 0 for x = 0
** m-exp-zero-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-zero-fn min max)
   #+END_SRC
   exp interpolation for midivalues (x = [0..127])
** m-exp-zero-rev-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-zero-rev-fn min max)
   #+END_SRC
   exp reverse interpolation fn returning midivalues [0..127]
** m-lin
   Function
   #+BEGIN_SRC lisp
     (m-lin x min max)
   #+END_SRC
   Return the linear interpolation for a MIDI value in the range
   /[min..max]/ as a float value.
*** Arguments
    | =x=   | An input value in the range /[0..127]/ to be interpolated. |
    | =min= | The output value for /x = 0/.                              |
    | =max= | The output value for /x = 127/.                            |

*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (m-lin 0 10 20) ; => 10.0
      
      (m-lin 64 10 20) ; => 15.039371
      
      (m-lin 127 10 20)  ; => 20.0
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** m-lin-dev
   Function
   #+BEGIN_SRC lisp
     (m-lin-dev x max)
   #+END_SRC
   return a random deviation offset, the deviation being linearly
   interpolated between 0 for x=0 and [-max..max] for x=127.
** m-lin-fn
   Function
   #+BEGIN_SRC lisp
     (m-lin-fn min max)
   #+END_SRC
   linear interpolation for midivalues (x = [0..127])
** m-lin-rd-fn
   Function
   #+BEGIN_SRC lisp
     (m-lin-rd-fn min max)
   #+END_SRC
   rounded linear interpolation for midivalues (x = [0..127])
** m-lin-rd-rev-fn
   Function
   #+BEGIN_SRC lisp
     (m-lin-rd-rev-fn min max)
   #+END_SRC
** m-lin-rev-fn
   Function
   #+BEGIN_SRC lisp
     (m-lin-rev-fn min max)
   #+END_SRC
** make-adjustable-string
   Function
   #+BEGIN_SRC lisp
     (make-adjustable-string)
   #+END_SRC
** make-bang
   Function
   #+BEGIN_SRC lisp
     (make-bang &optional fn val)
   #+END_SRC
   create and return a [[bang-object][bang-object]] instance with trigger-fns set to /fn/
   and its ref-value set to /val/.
*** Arguments
    | =fn=  | A function or list of functions to call on the trigger function. |
    | =val= | The value of the ref-object.                                     |

*** Example
    #+BEGIN_SRC lisp
      (defparameter *test-bang* (make-bang (lambda () (format t "~&HiHo")) 2.5))
      
      (trigger *test-bang*) ;;; -> nil
      ;;; output in the REPL: HiHo
      
      (get-val *test-bang*) ;;; -> 2.5
      
      (set-val *test-bang* 42) ;;; -> 42
      
      (get-val *test-bang*) ;;; -> 42
    #+END_SRC
*** See also
    - [[bang-object][bang-object]]
    - [[get-val][get-val]]
    - [[ref-object][ref-object]]
    - [[set-val][set-val]]
    - [[trigger][trigger]]
** make-cm-line
   Function
   #+BEGIN_SRC lisp
     (make-cm-line args)
   #+END_SRC
   wrapper function for mapping.
** make-computed
   Function
   #+BEGIN_SRC lisp
     (make-computed fn &optional (setter nil))
   #+END_SRC
   Return a [[ref-object][ref-object]] which recalculates and sets its value using
   /fn/ whenever a ref-object accessed with [[get-val][get-val]] in the body of
   /fn/ is changed.
   
   Refer to [[clamps:Defining relations][Defining relations]] in the Clamps documentation for
   examples.
*** Arguments
    | =fn=     | Function of no arguments to call whenever a value accessed using [[get-val][get-val]] in the body of the function is changed.  |
    | =setter= | Function of one argument called with the value of the ref-object returned by /make-computed/ whenever it changes. |

*** See also
    - [[get-val][get-val]]
    - [[make-ref][make-ref]]
    - [[set-val][set-val]]
    - [[watch][watch]]
** make-keyword
   Function
   #+BEGIN_SRC lisp
     (make-keyword name)
   #+END_SRC
   Return a keyword from /name/.
*** Arguments
    | =name= | String to intern |

*** Example
    #+BEGIN_SRC lisp
      (make-keyword "Hello") => :hello
    #+END_SRC
** make-led-pulsar
   Function
   #+BEGIN_SRC lisp
     (make-led-pulsar ccnum chan midi-output &key (freq 2) (pulse-width 0.5))
   #+END_SRC
   Return an "instance" (closure) of a pulse generator flashing a LED
   on an external MIDI Harware device by sending the values 0/127 using
   /ccnum/, /chan/ and /midi-output/. Use the /:freq/ and /:pulse-width/
   keywords to change the speed and duty cycle of the pulse.
   
   Funcalling the returned instance with the :start argument will start
   the pulse, funcalling it with the :stop argument will stop flashing,
   calling it with :freq <freq> or :pulse-width <pulse-width> will change
   the respective values.
*** Example
    #+BEGIN_SRC lisp
      (defvar *my-pulsar* (make-led-pulsar 32 1 (cm:ensure-jackmidi *midi-out1*)))
      
      (funcall *my-pulsar* :start)
      
      (funcall *my-pulsar* :freq 1)
      
      (funcall *my-pulsar* :pulse-width 0.1)
      
      (funcall *my-pulsar* :stop)
    #+END_SRC
** make-lsample
   Function
   #+BEGIN_SRC lisp
     (make-lsample &key ((:name #:name) nil) ((:buffer #:buffer) nil) ((:oneshot #:oneshot) nil) ((:keynum #:keynum) +sample-zero+) ((:loopstart #:loopstart) +sample-zero+) ((:amp #:amp) (sample 0)) ((:loopend #:loopend) +sample-zero+))
   #+END_SRC
** make-oasr
   Function
   #+BEGIN_SRC lisp
     (make-oasr suswidth suspan sustain-level &key (curve -4) base restart-level (real-time-p (allow-rt-memory-p)))
   #+END_SRC
   Create and return a new ENVELOPE structure with ATTACK-TIME, SUSTAIN-LEVEL
   and RELEASE-TIME.
   
   The curvature CURVE defaults to -4.
** make-quantlist
   Function
   #+BEGIN_SRC lisp
     (make-quantlist vals)
   #+END_SRC
   Return the sorted list of quantization points in fractions of a beat
   [0..1] for a list of the beat division numbers to be considered,
   supplied in /vals/.
*** Arguments
    | =vals= | List of integer beat-divisions to be collected. |

*** Examples
    #+BEGIN_SRC lisp
      (make-quantlist '(4)) ; => (0 1/4 1/2 3/4 1)
      
      (make-quantlist '(3 4)) ; => (0 1/4 1/3 1/2 2/3 3/4 1)
      
      (make-quantlist '(3 4 5)) ; => (0 1/5 1/4 1/3 2/5 1/2 3/5 2/3 3/4 4/5 1)
    #+END_SRC
*** See also
    - [[quantize-time][quantize-time]]
** make-ref
   Function
   #+BEGIN_SRC lisp
     (make-ref val &rest args)
   #+END_SRC
   Return an instance of [[ref-object][ref-object]] with initial value /val/.
*** Arguments
    | =val=  | Initial value of the created instance. It can be of any type.                                                                           |
    | =args= | Optional args supplied to make-instance. They are used internally and are not intended to be used directly when working with /cl-refs/. |

*** See also
    - [[bang-object][bang-object]]
    - [[get-val][get-val]]
    - [[make-computed][make-computed]]
    - [[ref-object][ref-object]]
    - [[set-val][set-val]]
    - [[watch][watch]]
** map-all-pairs
   Function
   #+BEGIN_SRC lisp
     (map-all-pairs return-type fn list)
   #+END_SRC
   Execute /fn/ on all possible pairs of two different elements of
   /list/. The pairs are given to fn in the order of appearance in the
   list. /return-type/ serves the same purpose as in #'map.
*** Arguments
    | =return-type= | A Sequence type or nil.                                         |
    | =fn=          | Function of two arguments called on all pairs.                  |
    | =list=        | List containing all elements to which fn gets applied pairwise. |

*** Example
    #+BEGIN_SRC lisp
      (map-all-pairs 'list #'list '(1 2 3 4 5))
      ;; => ((1 2) (1 3) (1 4) (1 5) (2 3) (2 4) (2 5) (3 4) (3 5) (4 5))
    #+END_SRC
** map-indexed
   Macro
   #+BEGIN_SRC lisp
     (map-indexed result-type fn &rest seqs)
   #+END_SRC
   Map /fn/ over /seqs/ with incrementing zero-based idx. The idx will
   get supplied as first arg to /fn/. /result-type/ serves the same
   purpose as in #'map.
*** Arguments
    | =result-type= | Result type to return. If nil, don't return a result.                            |
    | =fn=          | Function to map over sequences. Needs to accept /(+ 1 (length seqs))/ arguments. |
    | =seqs=        | One or more sequences where mapping gets applied, similar to map.                |

*** Example
    #+BEGIN_SRC lisp
      (map-indexed 'list #'list '(a b c d e)  '(20 10 30 50 40))
      ;; => ((0 a 20) (1 b 10) (2 c 30) (3 d 50) (4 e 40))
    #+END_SRC
** map-params
   Macro
   #+BEGIN_SRC lisp
     (map-params syms values)
   #+END_SRC
** map-proplist
   Macro
   #+BEGIN_SRC lisp
     (map-proplist fn proplist)
   #+END_SRC
   Like mapcar but traversing a property list. /fn/ has to accept two
   values, the key and the value of each property in the proplist.
*** Arguments
    | =fn=       | Function to apply to all entries of the property list. |
    | =proplist= | Property list to traverse.                             |

*** Example
    #+BEGIN_SRC lisp
      (map-proplist #'list '(:a 2 :b 5 :c 4)) ; => ((:a 2) (:b 5) (:c 4))
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist][do-proplist]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-prop][get-prop]]
    - [[get-props-list][get-props-list]]
    - [[with-props][with-props]]
** map-tree
   Function
   #+BEGIN_SRC lisp
     (map-tree fn tree &key (test (lambda (elem) (not (consp elem)))))
   #+END_SRC
   Map function recursively and non-destructively on all leaf nodes of
   given tree (represented as a nested list). Leaf nodes are determind by
   applying #'test on the list containing them. If /test/ returns /t/,
   the node is considered to be a leaf node. Return the modified tree as
   a new structure.
*** Arguments
    | =fn=   | Function to call on the leaf nodes. |
    | =tree= | List to traverse, possibly nested   |

*** Examples
    #+BEGIN_SRC lisp
      (map-tree #'print '(1 (2 7 (8 9 ((17 15 (14)) 5 (3))))))
      ;; => (1 (2 7 (8 9 ((17 15 (14)) 5 (3)))))
      ;; output in the REPL:
      1 
      2 
      7 
      8 
      9 
      17 
      15 
      14 
      5 
      3 
      
      (map-tree (lambda (x) (+ x 100)) '(1 (2 7 (8 9 ((17 15 (14)) 5 (3))))))
      ;; => (101 (102 107 (108 109 ((117 115 (114)) 105 (103)))))
    #+END_SRC
** mappend
   Function
   #+BEGIN_SRC lisp
     (mappend fn list)
   #+END_SRC
   Append the results of calling fn on each element of list.
     Like mapcon, but uses append instead of nconc. Copied from Peter
     Norvig's AIP book.
** mapply
   Macro
   #+BEGIN_SRC lisp
     (mapply fn liste)
   #+END_SRC
** master-amp-bus-levelmeter-gui
   Function
   #+BEGIN_SRC lisp
     (master-amp-bus-levelmeter-gui id gui-parent &key (#:group 300) (audio-bus 0) (out-chan 0) (num-channels 1) (amp (make-ref 1)) (amp-slider (make-ref (amp->db-slider 1))) meter-refs (meter-display (make-ref :post)) (bus-name "") (min -40) (max 12) nb-ampdb)
   #+END_SRC
** master-amp-meter-bus
   Class

** master-amp-out-levelmeter-gui
   Function
   #+BEGIN_SRC lisp
     (master-amp-out-levelmeter-gui id gui-parent &key (#:group 300) (out-chan 0) (num-channels 1) (amp (make-ref 1)) (amp-slider (make-ref (amp->db-slider 1))) meter-refs (meter-display (make-ref :post)) (bus-name "") (min -40) (max 12) nb-ampdb)
   #+END_SRC
** master-bus-levelmeter-gui
   Function
   #+BEGIN_SRC lisp
     (master-bus-levelmeter-gui id gui-parent &key (#:group 300) refs (num 1) (audio-bus 0) (channel-offset 0) (create-bus t) (bus-name ""))
   #+END_SRC
   audio bus based levelmeter (group 300) routing NUM audio buses
   starting at AUDIO-BUS to audio-out CHANNEL-OFFSET. If CREATE-BUS is
   nil just create the levelmeter.
** memorize-random-state
   Function
   #+BEGIN_SRC lisp
     (memorize-random-state)
   #+END_SRC
** meters
   Function
   #+BEGIN_SRC lisp
     (meters)
   #+END_SRC
   Open the levelmeter page at /<clamps-base-url>/meters/ in a
   Browser.
*** See also
    - [[clamps-base-url][clamps-base-url]]
    - [[gui][gui]]
** *​midi-cc-fns​*
   :PROPERTIES:
   :CUSTOM_ID: midi-cc-fns
   :END:
   Variable

   2-dimensional Array of 16x128 lists containing functions to be called
   on a received MIDI CC message individually for the 128 CC numbers on
   all 16 MIDI channels with the CC value as argument on the default midi input (*​midi-in1​*).
*** See also
    - [[#midi-cc-state][*​​midi-cc-state​​*]]
    - [[#midi-note-fns][*​​midi-note-fns​​*]]
    - [[#midi-note-state][*​​midi-note-state​​*]]
** *​midi-cc-state​*
   :PROPERTIES:
   :CUSTOM_ID: midi-cc-state
   :END:
   Variable

   2-dimensional Array of 16x128 [[ref-object][ref-objects]] reflecting the last received
   CC value of a MIDI CC message for all 128 CC numbers on all 16 MIDI
   channels of the default midi input (*​midi-in1​*).
*** See also
    - [[ccin][ccin]]
    - [[#midi-cc-fns][*​​midi-cc-fns​​*]]
    - [[#midi-note-fns][*​​midi-note-fns​​*]]
    - [[#midi-note-state][*​​midi-note-state​​*]]
** midi-controller
   Class

   Generic base class for midi controllers in the /cl-midictl/
   package. An instance of a class derived from /midi-controller/ should
   get initialized with [[add-midi-controller][add-midi-controller]] and removed with
   [[remove-midi-controller][remove-midi-controller]] in order to add/remove it to/from the midi
   controller registry.
   
   midi-controller implements the following slots with initargs
   being the keywords of the slot symbol:
   
   =cc-map= -- Array mapping CC nums to internal indexes of the instance.
   
   =keynum-map= -- Array mapping keynums to internal indexes of the instance.
   
   =cc-fns= -- Array of 128 lists storing functions to call when
   receiving a value at any of the 128 CC numbers.
   
   =cc-state= -- Array of 128 [[bang-object][bang-objects]] storing the last
   received CC value for each CC number.
   
   =chan= -- Integer in the range [1..16] denoting the MIDI channel.
   
   =echo= -- Boolean to en/disable echoing of midi input to midi output.
   
   =id= -- Keyword or Symbol to identify the controller in the registry.
   
   =last-note-on= -- The keynum of the last received note-on event with positive
   velocity.
   
   =midi-input= -- jackmidi:input-stream for MIDI input.
   
   =midi-output= -- jackmidi:output-stream for MIDI output.
   
   =note-fns= -- Array of 128 lists storing functions to call with the
   velocity as argument, mapped to a received note-on event on any of the
   128 keynumbers.
   
   =note-state= -- Array of 128 [[ref-object][ref-objects]] storing the last
   received velocity for each keynum.
   
   =unwatch= -- Storage for unwatch functions for the slots of the
   controller instance, handled internally.
*** See also
    - [[add-midi-controller][add-midi-controller]]
    - [[find-controller][find-controller]]
    - [[remove-midi-controller][remove-midi-controller]]
    - [[remove-all-midi-controllers][remove-all-midi-controllers]]
** *​midi-debug​*
   :PROPERTIES:
   :CUSTOM_ID: midi-debug
   :END:
   Variable

** *​midi-in1​*
   :PROPERTIES:
   :CUSTOM_ID: midi-in1
   :END:
   Variable

   Default clamps MIDI input stream of type /<jackmidi:input-stream>/.
*** See also
    - [[#midi-out1][*​​midi-out1​​*]]
** midi-input
   Generic Function
   #+BEGIN_SRC lisp
     (midi-input object)
   #+END_SRC
   Accessor method for the midi-input slot of an instance of type
   [[midi-controller][midi-controller]].
** *​midi-note-fns​*
   :PROPERTIES:
   :CUSTOM_ID: midi-note-fns
   :END:
   Variable

   2-dimensional Array of 16x128 lists containing functions to be called
   on a received MIDI note on message individually for all 128 keynums on
   all 16 MIDI channels with the velocity as argument on the default midi input (*​midi-in1​*).
*** See also
    - [[#midi-cc-fns][*​​midi-cc-fns​​*]]
    - [[#midi-cc-state][*​​midi-cc-state​​*]]
    - [[#midi-note-state][*​​midi-note-state​​*]]
** *​midi-note-state​*
   :PROPERTIES:
   :CUSTOM_ID: midi-note-state
   :END:
   Variable

   2-dimensional Array of 16x128 [[ref-object][ref-objects]] reflecting the last received
   velocity of a MIDI note on message for all 128 keynums on all 16 MIDI
   channels on the default midi input (*​midi-in1​*). 
*** See also
    - [[#midi-cc-fns][*​​midi-cc-fns​​*]]
    - [[#midi-cc-state][*​​midi-cc-state​​*]]
    - [[#midi-note-fns][*​​midi-note-fns​​*]]
** *​midi-out1​*
   :PROPERTIES:
   :CUSTOM_ID: midi-out1
   :END:
   Variable

   Default clamps MIDI output stream of type
   /<jackmidi:output-stream>/.
*** See also
    - [[#midi-in1][*​​midi-in1​​*]]
** midi-output
   Generic Function
   #+BEGIN_SRC lisp
     (midi-output object)
   #+END_SRC
   Accessor method for the midi-output slot of an instance of type
   [[midi-controller][midi-controller]].
** midi-port-cc-fns
   Function
   #+BEGIN_SRC lisp
     (midi-port-cc-fns instance)
   #+END_SRC
** midi-port-cc-state
   Function
   #+BEGIN_SRC lisp
     (midi-port-cc-state instance)
   #+END_SRC
** midi-port-note-fns
   Function
   #+BEGIN_SRC lisp
     (midi-port-note-fns instance)
   #+END_SRC
** midi-port-note-state
   Function
   #+BEGIN_SRC lisp
     (midi-port-note-state instance)
   #+END_SRC
** mix-bus-to-out
   Function
   #+BEGIN_SRC lisp
     (mix-bus-to-out &rest optional-keywords &aux (#:lambda-list '((startidx 16 (numchannels 8) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** msg
   Macro
   #+BEGIN_SRC lisp
     (msg type format-control &rest format-arguments)
   #+END_SRC
   Imported from incudine.util: Produce a formatted log message controlled
   by /format-control/ and /format-arguments/.
   
   /type/ should be one of :error, :warn, :info or :debug.
*** Arguments
    | =type=             | Keynum or Symbol from the following list:                              |
    |                    | /:error/                                                               |
    |                    | /:warn/                                                                |
    |                    | /:info/                                                                |
    |                    | /:debug/                                                               |
    | =format-control=   | A format control string like in Common Lisp's #'format function.       |
    | =format-arguments= | Zero or more format arguments like in Common Lisp's #'format function. |

*** See also
    - [[nrt-msg][nrt-msg]]
** mtof
   Function
   #+BEGIN_SRC lisp
     (mtof m &key (tuning-base 440))
   #+END_SRC
   Convert pitch in Midicts to frequency in Hz.
*** Arguments
    | =midi-value=   | Positive Number denoting Pitch in Midicents. |
    | =:tuning-base= | Frequency of A4 in Hz.                       |

*** Examples
    #+BEGIN_SRC lisp
      (mtof 69) ; => 440
      
      (mtof 60.5) ; => 269.29178
      
      (mtof 69 :tuning-base 415) ; => 415
    #+END_SRC
*** See also
    - [[ftom][ftom]]
** mton
   Function
   #+BEGIN_SRC lisp
     (mton m)
   #+END_SRC
   Return normalized value mapped from MIDI value m in the range
   [0..127] as a single float.
*** Arguments
    | =m= | Number in the range [0..127] |

*** Examples
    #+BEGIN_SRC lisp
      (mton 0) ; => 0
      
      (mton 13) ; => 0.10236221
      
      (mton 63.5) ; => 0.5
      
      (mton 127) ; => 1.0
    #+END_SRC
*** See also
    - [[ntom][ntom]]
** multf
   Macro
   #+BEGIN_SRC lisp
     (multf #:place &optional (number 1))
   #+END_SRC
   Like incf but multiplying instead of adding.
*** Arguments
    | =place=  | A setfable place.                            |
    | =number= | Number indicating the multiplication factor. |

*** Examples
    #+BEGIN_SRC lisp
      (defvar *test* 2) ; => *test*
      
      (multf *test* 3) ; => 6
      
      *test*  ; => 6
    #+END_SRC
* N
** n-apply
   Function
   #+BEGIN_SRC lisp
     (n-apply n fn &key (initial-value '()) (collect nil))
   #+END_SRC
   call fn n times accumulating the results in acc. fn should accept two
   values, the current n and the accumulated results of previous
   calls. If collect is t return all results in a list.
** n-exp
   Function
   #+BEGIN_SRC lisp
     (n-exp x min max)
   #+END_SRC
   Return the exponential interpolation for a normalized value in the
   range /[min..max]/ as a float value.
   
    @Arguments
   x - An input value in the range /[0..1]/ to be interpolated.
   min - The output value for /x = 0/.
   max - The output value for /x = 1/.
*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (n-exp 0 1 100) ; => 1.0
      
      (n-exp 0.5 1 100) ; => 10.0
      
      (n-exp 1 1 100) ; => 100.0
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** n-exp-dev
   Function
   #+BEGIN_SRC lisp
     (n-exp-dev x max)
   #+END_SRC
   Return a random deviation factor, the deviation being exponentially
   interpolated between /1/ for /x = 0/ and /[1/max..max]/ for /x = 1/.
*** Arguments
    | =x=   | An input value in the range /[0..1]/ to be interpolated. |
    | =max= | The maximum deviation factor for /x = 1/;                |

*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (n-exp-dev 0 4) ; => 1.0
      
      (n-exp-dev 0.5 4) ; a random value exponentially distributed in the range [0.5..2.0]
      
      (n-exp-dev 1 4) ; a random value exponentially distributed in the range [0.25..4.0]
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** n-exp-fn
   Function
   #+BEGIN_SRC lisp
     (n-exp-fn min max)
   #+END_SRC
   exponential interpolation for normalized x.
** n-exp-rev-fn
   Function
   #+BEGIN_SRC lisp
     (n-exp-rev-fn min max)
   #+END_SRC
   reverse of exponential interpolation for normalized x.
** n-exp-zero
   Function
   #+BEGIN_SRC lisp
     (n-exp-zero x min max)
   #+END_SRC
   exp interpolation for normalized values (x = [0..1]) with 0 for x = 0
** n-lin
   Function
   #+BEGIN_SRC lisp
     (n-lin x min max)
   #+END_SRC
   Return the linear interpolation for a normalized value in the range
   /[min..max]/ as a float value.
*** Arguments
    | =x=   | An input value in the range /[0..1]/ to be interpolated. |
    | =min= | The output value for /x = 0/.                            |
    | =max= | The output value for /x = 1/.                            |

*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (n-lin 0 10 20) ; => 10.0
      
      (n-lin 0.5 10 20) ; => 15.0
      
      (n-lin 1 10 20)  ; => 20.0
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin-dev][n-lin-dev]]
** n-lin-dev
   Function
   #+BEGIN_SRC lisp
     (n-lin-dev x max)
   #+END_SRC
   Return a random deviation value, the deviation being linearly
   interpolated between /0/ for /x = 0/ and /[-max..max]/ for /x = 1/.
*** Arguments
    | =x=   | An input value in the range /[0..1]/ to be interpolated. |
    | =max= | The maximum deviation value for /x = 1/;                 |

*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (n-lin-dev 0 4) ; => 0
      
      (n-lin-dev 0.5 4) ; a random value linearly distributed in the range [-2.0..2.0]
      
      (n-lin-dev 1 4) ; a random value linearly distributed in the range [-4.0..4.0]
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
** n-lin-fn
   Function
   #+BEGIN_SRC lisp
     (n-lin-fn min max)
   #+END_SRC
   linear interpolation for normalized x.
** n-lin-rev-fn
   Function
   #+BEGIN_SRC lisp
     (n-lin-rev-fn min max)
   #+END_SRC
   reverse of linear interpolation for normalized x.
** named-amp-bus
   Class

** named-bus
   Class

   Class for an incudine audio bus.
   
   named-bus is derived from [[cuda-dsp][cuda-dsp]]. It implements the following
   slots with accessor methods of the same name (if not indicated
   otherwise) and initargs being the keywords of the slot symbol:
   
   =name= -- String naming the bus. Accessor is [[bus-name][bus-name]]. Defaults to the empty string.
   
   =num-chans= -- Positive Integer denoting the number of channels. Defaults to 2. Accessor is [[num-channels][num-channels]]
   
   =audio-bus= -- Non Negative Integer denoting the bus number. Defaults to 0.
   
   =create-bus= -- Boolean denoting whether to create the dsp on initialization. Defaults to /t/.
   
   =channel-offset= -- Non Negative Integer denoting the channel offset of the audio output. Defaults to 0.
*** See also
    - [[cuda-dsp][cuda-dsp]]
** nanoktl2-midi
   Class

   Class for a Korg Nanokontrol2 midi controller. This class contains the
   state of the Hardware Controller in respect to the Knobs, Faders and
   Buttons of the device. If the device is connected bidirectionally to
   the midi Ports and the instance is created with
   [[add-midi-controller][add-midi-controller]], the following behaviour is implemented:
   
   - Moving the hardware faders will update the respective slots of the
     instance. Note that the values of the slots for the faders and
     buttons are normalized to the range [0..1].
   
   - Setting the values of the button slots of the instance to 0, 1 or 2
     will highlight the respective button on the hardware controller.
     [fn::For this to work, the LED mode of the NanoKONTROL2 has to be
     set to /External/ (see [[clamps:Using a Korg NanoKONTROL2
     Controller][Using a Korg NanoKONTROL2 Controller]])]
   
   - Pressing a button on the Hardware controller will call the
     [[trigger][trigger]] function with the corresponding slot of the instance as
     argument.
   
   See [[clamps:Using a Korg NanoKONTROL2 Controller][Using a Korg NanoKONTROL2 Controller]] in the Clamps
   Packages documentation for usage examples.
   
   nanoktl2-midi implements the following slots with accessor methods of
   the same name and initargs being the keywords of the slot symbol:
   
   =cc-nums= -- Array of 51 elements containing the CC numbers of all
   knobs, faders and buttons of the NanoKontrol2 in the following
   order (with their array idxs in brackets):
   
   | knobs [0..7]    | faders [8..15]   | s-buttons [16..23] | m-buttons [24..31] | r-buttons [32..39] |                   |
   | track-left [40] | track-right [41] | cycle[42]          | set [43]           | marker-left [44]   | marker-right [45] |
   | rew [46]        | ff [47]          | stop [48]          | play [49]          | rec [50]           |                   |
   
   =cc-state= -- Array of 51 [[bang-object][bang-objects]] or [[ref-object][ref-objects]] containing the state (value)
   of all buttons and faders of the NanoKontrol2 in the same idx order, as in =cc-nums=.
   
   =nk2-faders= -- Array of 16 elements containing the
   [[ref-object][ref-objects]] of the 8 knobs and the 8 faders of the
   NanoKontrol2 (same as ccstate[0..15]).
   
   =nk2-fader-modes= -- Array of 16 elements containing the mode of the
   fader when the hardware fader is out of sync with the program state of
   the fader. Currently implemented are:
   
   - /:scale/ Scale fader values when moving the hardware fader.
   - /:jump/ Jump to the value when moving the hardware fader.
   - /:catch/ Catch the slot-value when moving the hardware fader.
   
   =nk2-fader-test-sync-fns= -- Array of 16 functions, invoked if fader-mode /:catch/ is used.
   
   =nk2-fader-last-cc= -- Array of 16 values containing the last (normalized) received CC values of the hardware faders.
   
   =button-labels= -- Array of 35 elements containing the labels of all
   buttons of the NanoKontrol2.
   
   =s-buttons= -- Array of 8 [[bang-object][bang-objects]] containing the state of the 8 S buttons with a value of 0, 1 or 2 (same as ccstate[16..23]).
   
   =m-buttons= -- Array of 8 [[bang-object][bang-objects]] containing the state of the 8 M buttons with a value of 0, 1 or 2 (same as ccstate[24..31]).
   
   =r-buttons= -- Array of 8 [[bang-object][bang-objects]] containing the state of the 8 R buttons with a value of 0 or 1 (same as ccstate[32..39]).
   
   =track-left= -- [[bang-object][bang-object]] of the track left button (same as ccstate[40]).
   
   =track-right= -- [[bang-object][bang-object]] of the track right button (same as ccstate[41]).
   
   =cycle= -- [[bang-object][bang-object]] of the cycle button (same as ccstate[42]).
   
   =set-marker= -- [[bang-object][bang-object]] of the set marker button (same as ccstate[43]).
   
   =marker-left= -- [[bang-object][bang-object]] of the marker left button (same as ccstate[44]).
   
   =marker-right= -- [[bang-object][bang-object]] of the marker right button (same as ccstate[45]).
   
   =tr-rewind= -- [[bang-object][bang-object]] of the rewind transport button (same as ccstate[46]).
   
   =tr-ffwd= -- [[bang-object][bang-object]] of the fast forward transport button (same as ccstate[47]).
   
   =tr-stop= -- [[bang-object][bang-object]] of the stop transport button (same as ccstate[48]).
   
   =tr-play= -- [[bang-object][bang-object]] of the play transport button (same as ccstate[49]).
   
   =tr-record= -- [[bang-object][bang-object]] of the record transport button (same as ccstate[50]).
*** See also
    - [[midi-controller][midi-controller]]
** nanoktl2-preset-gui
   Function
   #+BEGIN_SRC lisp
     (nanoktl2-preset-gui #:id container &key (chan 5))
   #+END_SRC
** nanoktl2-preset-midi
   Class

** new-id
   Function
   #+BEGIN_SRC lisp
     (new-id svg-file id-type)
   #+END_SRC
** nk2-fader-test-sync-fns
   Generic Function
   #+BEGIN_SRC lisp
     (nk2-fader-test-sync-fns object)
   #+END_SRC
   automatically generated reader method
** node-free-unprotected
   Function
   #+BEGIN_SRC lisp
     (node-free-unprotected)
   #+END_SRC
   Free all Incudine nodes of /group 200/. For details of the function of
   this group refer to section
   [[clamps:General Incudine Setup][General Incudine Setup]] in Clamps Packages.
*** See also
    - [[rts-hush][rts-hush]]
** node-group
   Generic Function
   #+BEGIN_SRC lisp
     (node-group object)
   #+END_SRC
   Accessor for the node-group slot of dsp /object/.
*** See also
    - [[cuda-dsp][cuda-dsp]]
** nrt-msg
   Macro
   #+BEGIN_SRC lisp
     (nrt-msg type format-control &rest format-arguments)
   #+END_SRC
   Imported from incudine.util: Produce a formatted log message in the
   nrt-thread controlled by /format-control/ and /format-arguments/.
   
   /type/ should be one of :error, :warn, :info or :debug.
*** Arguments
    | =type=             | Keynum or Symbol from the following list:                              |
    |                    | /:error/                                                               |
    |                    | /:warn/                                                                |
    |                    | /:info/                                                                |
    |                    | /:debug/                                                               |
    | =format-control=   | A format control string like in Common Lisp's #'format function.       |
    | =format-arguments= | Zero or more format arguments like in Common Lisp's #'format function. |

*** See also
    - [[msg][msg]]
** ntom
   Function
   #+BEGIN_SRC lisp
     (ntom n)
   #+END_SRC
   Return rounded MIDI value mapped from normalized n in the range
   [0..1].
*** Arguments
    | =n= | Number in the range [0..1] |

*** Examples
    #+BEGIN_SRC lisp
      (ntom 0) ; => 0
      
      (ntom 0.1) ; => 13
      
      (ntom 0.5) ; => 64
      
      (ntom 1) ; => 127
    #+END_SRC
*** See also
    - [[mton][mton]]
** num-channels
   Generic Function
   #+BEGIN_SRC lisp
     (num-channels object)
   #+END_SRC
   automatically generated reader method
* O
** on-deps-update
   Macro
   #+BEGIN_SRC lisp
     (on-deps-update &rest body)
   #+END_SRC
   return body if *​update-deps​* is non-nil, otherwise return nil.
** open
   Function
   #+BEGIN_SRC lisp
     (open filename &key (direction :input) (element-type 'character) (if-exists nil if-exists-given) (if-does-not-exist nil if-does-not-exist-given) (external-format :default) (class 'fd-stream))
   #+END_SRC
   Return a stream which reads from or writes to FILENAME.
     Defined keywords:
      :DIRECTION - one of :INPUT, :OUTPUT, :IO, or :PROBE
      :ELEMENT-TYPE - the type of object to read or write, default CHARACTER
      :IF-EXISTS - one of :ERROR, :NEW-VERSION, :RENAME, :RENAME-AND-DELETE,
                          :OVERWRITE, :APPEND, :SUPERSEDE or NIL
      :IF-DOES-NOT-EXIST - one of :ERROR, :CREATE or NIL
     See the manual for details.
** open
   Function
   #+BEGIN_SRC lisp
     (open &key (host *host*) (port *in-port*) (direction :input) (element-type 'character) (protocol :tcp))
   #+END_SRC
** open-midi-port
   Function
   #+BEGIN_SRC lisp
     (open-midi-port id)
   #+END_SRC
   Register a new midi port struct, open its midi input and output,
   define and start its default responders and return the struct.
*** Arguments
    | =id= | Keyword or Symbol denoting the id of the midi port. |

*** See also
    - [[close-midi-port][close-midi-port]]
    - [[find-midi-port][find-midi-port]]
    - [[list-midi-ports][list-midi-ports]]
** osc-midi-write-short
   Function
   #+BEGIN_SRC lisp
     (osc-midi-write-short stream st d1 d2)
   #+END_SRC
** osc~
   Function
   #+BEGIN_SRC lisp
     (osc~ &rest optional-keywords &aux (#:lambda-list '((freq 440 (amp 0.1) (phase 0) (master 1.0) (buf *cosine-table*) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
   table lookup cosine oscillator.
** *​out-refs​*
   :PROPERTIES:
   :CUSTOM_ID: out-refs
   :END:
   Variable

** out-stream-open?
   Function
   #+BEGIN_SRC lisp
     (out-stream-open? s)
   #+END_SRC
** output-stream
   Structure

** output-stream-p
   Function
   #+BEGIN_SRC lisp
     (output-stream-p object)
   #+END_SRC
* P
** partition-seq
   Function
   #+BEGIN_SRC lisp
     (partition-seq seq pred)
   #+END_SRC
   Partition /seq/ into sublists based on a predicate called on successive
   elements. /pred/ is a function of two args, an element of the seq and
   its successor. If pred returns non-nil, a new subseq is started after
   the current element. The result contains all elements of the original
   seq in orginal order.
*** Example
    #+BEGIN_SRC lisp
      (partition-seq '(1 2 4 5 6 8 9) #'(lambda (x y) (> (- y x) 1))) 
      ;; => ((1 2) (4 5 6) (8 9))
      
      (partition-seq '(1 2 4 5 6 8 9) #'(lambda (x y) t)) 
      ;; => ((1) (2) (4) (5) (6) (8) (9))
    #+END_SRC
** path-find-file
   Function
   #+BEGIN_SRC lisp
     (path-find-file fname path)
   #+END_SRC
   Return the full pathname of the first occurence of fname in path.
*** Arguments
    | =fname= | String or Pathname of file. |
    | =path=  | List of paths to search.    |

** permute
   Function
   #+BEGIN_SRC lisp
     (permute list permutation)
   #+END_SRC
   Return a permutation of /list/ according to the indexes in
   /permutation/.
*** Arguments
    | =list=        | List of elements to be permuted. |
    | =permutation= | List of permutation indexes.     |

*** Examples
    #+BEGIN_SRC lisp
      (permute '(1 2 3 4 5) '(3 1 4 2 0)) ; => (4 2 5 3 1)
    #+END_SRC
*** Note
    For a valid permutation the /permutation/ index list should contain
    all integer indexes of list starting from zero. In that case, length
    of /list/ is equal to the length of /permutation/. If it is shorter,
    an error occurs, if it is longer, not all elements of /list/ are
    returned.
** phasor*
   :PROPERTIES:
   :CUSTOM_ID: phasor
   :END:
   Incudine VUG
   #+BEGIN_SRC lisp
     (phasor* (freq sample) (#:init sample))
   #+END_SRC
   Ugen of a phasor working with any block size.
*** Arguments
    | =freq= | Number denoting frequency in Hz. |
    | =init= | Number denoting initial phase.   |

*** See also
    - [[#buffer-loop-play][buffer-loop-play​*]]
    - [[#buffer-play][buffer-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#line][line​*]]
    - [[#phasor-loop][phasor-loop​*]]
    - [[#play-buffer][play-buffer​*]]
    - [[#play-buffer-loop][play-buffer-loop​*]]
    - [[#play-buffer-stretch][play-buffer-stretch​*]]
    - [[#play-buffer-stretch-env-pan-out][play-buffer-stretch-env-pan-out​*]]
** phasor-loop*
   :PROPERTIES:
   :CUSTOM_ID: phasor-loop
   :END:
   Incudine VUG
   #+BEGIN_SRC lisp
     (phasor-loop* (rate sample) (start-pos sample) (loopstart sample) (loopend sample))
   #+END_SRC
   Ugen of a looping phasor working with any block size.
*** Arguments
    | =rate=      | Number denoting sample increment.            |
    | =start-pos= | Number denoting initial position.            |
    | =loopstart= | Non Negative Integer denoting start of loop. |
    | =loopend=   | Non Negative Integer denoting end of loop.   |

*** See also
    - [[#buffer-loop-play][buffer-loop-play​*]]
    - [[#buffer-play][buffer-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#line][line​*]]
    - [[#phasor][phasor​*]]
    - [[#play-buffer][play-buffer​*]]
    - [[#play-buffer-loop][play-buffer-loop​*]]
    - [[#play-buffer-stretch][play-buffer-stretch​*]]
    - [[#play-buffer-stretch-env-pan-out][play-buffer-stretch-env-pan-out​*]]
** play-buffer*
   :PROPERTIES:
   :CUSTOM_ID: play-buffer
   :END:
   Incudine DSP Function
   #+BEGIN_SRC lisp
     (play-buffer* &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (dur 1) (amp 0) (rate 1) (pan 0.5) (startpos 0) (out1 0) (out2 1) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
   Play /buffer/ with /env/ for /dur/ seconds and /amp/ in dB at /rate/,
   with /pan/ from /startpos/ seconds into the sample. Output will be panned
   between /out1/ and /out2/. All other keywords of incudine dsps also
   apply. Works with any block size.
*** Arguments
    | =buffer=   | Incudine Buffer.                                                                                       |
    | =env=      | Incudine Envelope.                                                                                     |
    | =dur=      | Positive Number denoting duration.                                                                     |
    | =amp=      | Positive Number denoting amplitude in dB. The dB range [-100..0] is mapped to the linear range [0..1]. |
    | =rate=     | Positive Number denoting playback rate, adjusted for the sample rate of buffer.                        |
    | =pan=      | Number in the range [0..1] denoting panorama between out1 and out2.                                    |
    | =startpos= | Positive Number denoting in seconds into the buffer.                                                   |
    | =out1=     | Non Negative Integer denoting first output channel.                                                    |
    | =out2=     | Non Negative Integer denoting second output channel.                                                   |

*** See also
    - [[#buffer-play][buffer-play​*]]
    - [[#buffer-loop-play][buffer-loop-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#line][line​*]]
    - [[lsample][lsample]]
    - [[#phasor][phasor​*]]
    - [[#phasor-loop][phasor-loop​*]]
    - [[#play-buffer-loop][play-buffer-loop​*]]
    - [[#play-buffer-stretch][play-buffer-stretch​*]]
    - [[#play-buffer-stretch-env-pan-out][play-buffer-stretch-env-pan-out​*]]
    - [[play-lsample][play-lsample]]
** play-buffer-loop*
   :PROPERTIES:
   :CUSTOM_ID: play-buffer-loop
   :END:
   Incudine DSP Function
   #+BEGIN_SRC lisp
     (play-buffer-loop* &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (dur 1) (amp 0) (rate 1) (pan 0.5) (loopstart 0) (loopend 0) (start 0) (out1 0) (out2 1) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
   Play /buffer/ with /env/ for /dur/ seconds and /amp/ in dB at /rate/,
   with /pan/ from /start/ seconds into the sample. Loop the playback
   between /loopstart/ and /loopend/. /loopend/ of 0 denotes end of
   buffer. Output will be panned between /out1/ and /out2/. All other
   keywords of incudine dsps also apply. Works with any block size.
*** Arguments
    | =buffer=    | Incudine Buffer.                                                                                       |
    | =env=       | Incudine Envelope.                                                                                     |
    | =dur=       | Positive Number denoting duration.                                                                     |
    | =amp=       | Positive Number denoting amplitude in dB. The dB range [-100..0] is mapped to the linear range [0..1]. |
    | =rate=      | Positive Number denoting playback rate, adjusted for the sample rate of buffer.                        |
    | =pan=       | Number in the range [0..1] denoting panorama between out1 and out2.                                    |
    | =loopstart= | Positive Number denoting start of loop.                                                                |
    | =loopstart= | Positive Number denoting end of loop.                                                                  |
    | =out1=      | Non Negative Integer denoting first output channel.                                                    |
    | =out2=      | Non Negative Integer denoting second output channel.                                                   |

*** See also
    - [[#buffer-play][buffer-play​*]]
    - [[#buffer-loop-play][buffer-loop-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#line][line​*]]
    - [[lsample][lsample]]
    - [[#phasor][phasor​*]]
    - [[#phasor-loop][phasor-loop​*]]
    - [[#play-buffer][play-buffer​*]]
    - [[#play-buffer-stretch][play-buffer-stretch​*]]
    - [[#play-buffer-stretch-env-pan-out][play-buffer-stretch-env-pan-out​*]]
    - [[play-lsample][play-lsample]]
** play-buffer-stretch*
   :PROPERTIES:
   :CUSTOM_ID: play-buffer-stretch
   :END:
   Incudine DSP Function
   #+BEGIN_SRC lisp
     (play-buffer-stretch* &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (amp 0) (transp 0) (start 0) (end 0) (stretch 1) (wwidth 137) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
   Play /buffer/ using 2 window overlap add granular
   stretching/transposition with /env/ between /start/ and /end/, /amp/
   in dB, transposition /transp/, /stretch/ and grain window size
   /wwidth/ to output 0. All other keywords of incudine dsps also
   apply. Works with any block size.
*** Arguments
    | =buffer=  | Incudine Buffer.                                                                                       |
    | =env=     | Incudine Envelope.                                                                                     |
    | =amp=     | Positive Number denoting amplitude in dB. The dB range [-100..0] is mapped to the linear range [0..1]. |
    | =transp=  | Number denoting transposition in Midicents.                                                            |
    | =start=   | Number denoting the start in seconds into the buffer (at buffer rate).                                 |
    | =end=     | Number denoting the end in seconds into the buffer (at buffer rate). Zero denotes end of buffer.       |
    | =stretch= | Positive Number denoting time stretching factor of playback.                                           |
    | =wwidth=  | Positive Number denoting granular window width in msecs.                                               |

*** See also
    - [[#buffer-play][buffer-play​*]]
    - [[#buffer-loop-play][buffer-loop-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#line][line​*]]
    - [[lsample][lsample]]
    - [[#phasor][phasor​*]]
    - [[#phasor-loop][phasor-loop​*]]
    - [[#play-buffer][play-buffer​*]]
    - [[#play-buffer-loop][play-buffer-loop​*]]
    - [[#play-buffer-stretch-env-pan-out][play-buffer-stretch-env-pan-out​*]]
    - [[play-lsample][play-lsample]]
** play-buffer-stretch-env-pan-out*
   :PROPERTIES:
   :CUSTOM_ID: play-buffer-stretch-env-pan-out
   :END:
   Incudine DSP Function
   #+BEGIN_SRC lisp
     (play-buffer-stretch-env-pan-out* &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (amp 0) (transp 0) (start 0) (end 0) (stretch 1) (wwidth 137) (attack 0) (release 0.01) (pan 0) (out1 0) (out2 1) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
   Play /buffer/ using 2 window overlap add granular
   stretching/transposition with /env/ between /start/ and /end/, /amp/
   in dB, transposition /transp/, /stretch/ and grain window size
   /wwidth/, /attack/ and /release/. Output will be panned between /out1/
   and /out2/. All other keywords of incudine dsps also apply. Works with
   any block size.
*** Arguments
    | =buffer=  | Incudine Buffer.                                                                                       |
    | =env=     | Incudine Envelope.                                                                                     |
    | =amp=     | Positive Number denoting amplitude in dB. The dB range [-100..0] is mapped to the linear range [0..1]. |
    | =transp=  | Number denoting transposition in Midicents.                                                            |
    | =start=   | Number denoting the start in seconds into the buffer (at buffer rate).                                 |
    | =end=     | Number denoting the end in seconds into the buffer (at buffer rate). Zero denotes end of buffer.       |
    | =stretch= | Positive Number denoting time stretching factor of playback.                                           |
    | =wwidth=  | Positive Number denoting granular window width in msecs.                                               |
    | =attack=  | Positive Number in the range [0..1] denoting attack time as a fraction of the duration.                |
    | =release= | Positive Number in the range [0..1] denoting release time as a fraction of the duration.               |
    | =pan=     | Number in the range [0..1] denoting panorama between out1 and out2.                                    |
    | =out1=    | Non Negative Integer denoting first output channel. Defaults to 0.                                     |
    | =out2=    | Non Negative Integer denoting second output channel. Defaults to (1+ out1).                            |

*** See also
    - [[#buffer-play][buffer-play​*]]
    - [[#buffer-loop-play][buffer-loop-play​*]]
    - [[#buffer-stretch-play][buffer-stretch-play​*]]
    - [[#envelope][envelope​*]]
    - [[#line][line​*]]
    - [[lsample][lsample]]
    - [[#phasor][phasor​*]]
    - [[#phasor-loop][phasor-loop​*]]
    - [[#play-buffer][play-buffer​*]]
    - [[#play-buffer-loop][play-buffer-loop​*]]
    - [[#play-buffer-stretch][play-buffer-stretch​*]]
    - [[play-lsample][play-lsample]]
** play-lsample
   Function
   #+BEGIN_SRC lisp
     (play-lsample lsample pitch ampdb duration &key (pan 0.5) (startpos 0) (oneshot nil osp) out1 out2)
   #+END_SRC
   Play /lsample/ with given /pitch/, /ampdb/ and /duration/, /pan/ and
   /startpos/ with or without looping.
*** Arguments
    | =lsample=   | Instance of type lsample                                                          |
    | =pitch=     | Positive Number denoting pitch in Midicents.                                      |
    | =ampdb=     | Positive number denoting amp in dB, mapping range [-100..0] to linear amp [0..1]. |
    | =duration=  | Positive number denoting duration in seconds.                                     |
    | =:pan=      | Number denoting equal power panorama in the range [0..1].                         |
    | =:startpos= | Positive number denoting start position into the sample in seconds.               |
    | =:oneshot=  | Boolean indicating whether not to loop the sample on playback.                    |

*** See also
    - [[lsample][lsample]]
** play-sfz
   Function
   #+BEGIN_SRC lisp
     (play-sfz pitch db dur &key (pan 0.5) (preset :flute-nv) (startpos 0) (out1 0) out2 (oneshot nil osp))
   #+END_SRC
   Play a sfz preset with stereo panning to incudine's audio outputs
   with index /out1/ and /out2/, not looping if /oneshot/ is non-nil or
   set in the lsample.
*** Arguments
    | =pitch=     | Pitch in Midicent.                                                                                           |
    | =db=        | Amplitude in dB, the range [-100..0] corresponding to linear values [0..1].                                  |
    | =dur=       | Duration in seconds.                                                                                         |
    | =:pan=      | Number in the range /[0..1]/ defining equal power panning between /out0/ and /out1/.                         |
    | =:preset=   | The name of a registered preset. If the preset hasn't been loaded it will get loaded before playback starts. |
    | =:startpos= | The startposition in the sample in seconds.                                                                  |
    | =:out1=     | Zero based index of the first outlet.                                                                        |
    | =:out2=     | Zero based index of the second outlet. If not specified, /(mod (1+ out1) 8)/ will be used.                   |
    | =:oneshot=  | Boolean denoting whether not to loop the playback.                                                           |

*** Note
    The setting of [[standard-pitch][standard-pitch]] is taken into account!
** plot
   Generic Function
   #+BEGIN_SRC lisp
     (plot data &rest args &key region header options grid x-axis num-values data-fn &allow-other-keys)
   #+END_SRC
   Plot input data given as an incudine envelope.
** plot-2d
   Function
   #+BEGIN_SRC lisp
     (plot-2d data &rest args &key region header options grid &allow-other-keys)
   #+END_SRC
** points->svg
   Function
   #+BEGIN_SRC lisp
     (points->svg list svg-file &key color opacity radius)
   #+END_SRC
** poolevt
   Common Music Class
   #+BEGIN_SRC lisp
     (new poolevt &key time (lsample nil) (keynum 60) (amp 0) (start 0) (end 0) (stretch 1) (wwidth 123) (attack 0) (release 0.01) (pan 0.5) (adjust-stretch nil) (out1 0) out2)
   #+END_SRC
   Create a poolevt Event.
   
   poolevt accepts the following slot initializations:
   
   =:time= -- The output time in seconds, initially unbound.
   
   =:lsample= -- [[lsample]] struct to use for playback.
   
   =:keynum= -- Keynum in Midicents.
   
   =:amp= -- Amplitude in dB, the range [-100..0] corresponding to linear values [0..1].
   
   =:dy= -- Number denoting transposition in Midicents at end of playpack in relation to the beginning.
   
   =:start= -- Start offset into the sample in seconds.
   
   =:end= -- End time of sample sample in seconds. 0 denotes end of sample
   
   =:stretch= -- Non zero Number denoting stretch ratio. Negative indicates reverse playback.
   
   =:wwidth= -- Positive number denoting window size in ms for granular stretching.
   
   =:attack= -- Number in the range [0..1] indicating attack time ratio in relation to full length.
   
   =:release= -- Number in the range [0..1] indicating release time ratio in relation to full length.
   
   =:pan= -- Number in the range /[0..1]/ defining equal power panning
   between the two outputs of the dsp on playback.
   
   =:adjust-stretch= -- Boolean indicationg whether to adjust the stretch factor in relation to the transposition.
   
   =:out1= -- Non negative Integer denoting the left output channel index.
   
   =:out2= -- Non negative Integer denoting the right output channel index. Defaults to (1+ out1)
*** Examples
    #+BEGIN_SRC lisp
        (new poolevt)
        ;; => #i(poolevt lsample nil keynum nil amp 0.0 dy 0.0 start 0 end 0
        ;; stretch 1.0 wwidth 123 attack 0 release 0.01 pan 0.5 snd-id nil
        ;; adjust-stretch nil out1 0 out2 1)
      
        (output (new poolevt :lsample ...)) ; => ; No value
        ;; ; No values
    #+END_SRC
*** See also
    - [[dict:midi][midi]]
** port-available-p
   Function
   #+BEGIN_SRC lisp
     (port-available-p portno)
   #+END_SRC
   Check if IP port is available on /localhost/ by issuing shell
   command. Only works on Unix with the /lsof/ program installed.
*** Arguments
    | =portno= | Integer in the range [0..65535] |

** pulse-off
   Generic Function
   #+BEGIN_SRC lisp
     (pulse-off clog-obj)
   #+END_SRC
** pulse-on
   Generic Function
   #+BEGIN_SRC lisp
     (pulse-on clog-obj &optional freq)
   #+END_SRC
** push-if
   Macro
   #+BEGIN_SRC lisp
     (push-if form list)
   #+END_SRC
   Push form to list if form evaluates to non-nil. Return the modified
   list or nil if form evaluates to nil.
*** Arguments
    | =form= | Form to be pushed to list. |
    | =list= | List pushed into.          |

*** Examples
    #+BEGIN_SRC lisp
      (defvar *test* '()) ; => *test*
      
      (push-if 4 *test*) ; => (4)
      
      (push-if (eq 2 3) *test*) ; => nil
      
      *test* ; => (4)
    #+END_SRC
** pwd
   Function
   #+BEGIN_SRC lisp
     (pwd)
   #+END_SRC
   Return the current working directory as a pathname.
*** See also
    - [[cd][cd]]
* Q
** quantize-time
   Function
   #+BEGIN_SRC lisp
     (quantize-time val &optional (quantlist (make-quantlist '(3 4 5))))
   #+END_SRC
   Quantize the fractional part of /val/ to a quantization list
   /quantlist/ of possible quantization points in the range [0..1].
*** Arguments
    | =val=       | The value to be quantized.                                       |
    | =quantlist= | Sorted list of possible quantization points in the range [0..1]. |

*** Examples
    #+BEGIN_SRC lisp
      (quantize-time 1/7 (make-quantlist '(3 4 5))) ; => 1/5
      
      (quantize-time 37/7 (make-quantlist '(3 4 5))) ; => 21/4
      
      (quantize-time 17/7 (make-quantlist '(3 4 5))) ; => 12/5
      
      (quantize-time 17/7 (make-quantlist '(3 4))) ; => 5/2 
    #+END_SRC
*** See also
    - [[make-quantlist][make-quantlist]]
* R
** r-elt
   Function
   #+BEGIN_SRC lisp
     (r-elt seq)
   #+END_SRC
   Return a random element of seq.
*** Arguments
    | =seq= | a sequence fulfilling the predicate /(typep seq 'sequence)/ like a list or a vector. |

*** Examples
    #+BEGIN_SRC lisp
      (r-elt #(1 2 3 4)) ; => 1, 2, 3 or 4
      
      (r-elt '(dog cat bird cow)) ; => dog, cat, bird or cow
    #+END_SRC
** r-exp
   Function
   #+BEGIN_SRC lisp
     (r-exp min max)
   #+END_SRC
   Random value between [min..max] with exponential distribution.
*** Arguments
    | =min= | Number indicationg the minimum value. |
    | =max= | Number indicationg the maximum value. |

*** See also
    - [[r-lin][r-lin]]
** r-exp-dev
   Function
   #+BEGIN_SRC lisp
     (r-exp-dev max)
   #+END_SRC
   return a random deviation factor, the deviation being exponentially
   interpolated between 1 for x=0 and [1/max..max] for x=1.
** r-getf
   Function
   #+BEGIN_SRC lisp
     (r-getf list &rest props)
   #+END_SRC
   Recursively traverse nested /list/ using /props/ as idx. The values for
   props can be either keywords/symbols (using #'getf) or numbers (using
   #'elt).
*** Arguments
    | =list=  | a nested List to search.                                     |
    | =props= | one or more Keywords/Symbols, or Numbers interpreted as idx. |

*** Examples
    #+BEGIN_SRC lisp
      (defvar *geodata*
        '(:Italy
          (:Latium (:Rome (:Inhabitants 2749031 :size 1287.36 :River "Tevere"))
           :Lombardy (:Milano (:Inhabitants 1349930 :size 182 :River "Naviglio Grande")))
          :Kenia
          (:Nairobi (:Nairobi (:Inhabitants 4397073 :size 703.9 :River "Athi")))
          :Germany
          (:Bavaria (:Munich (:Inhabitants 1510378 :size 310.7 :River "Isar"))
           :Berlin (:Berlin (:Inhabitants 6340918 :size 891.7 :River "Spree")))))
      
      (r-getf *geodata* :Kenia :Nairobi :Nairobi :Inhabitants) ; => 4397073
      
      (r-getf *geodata* :Germany)
      
      ;; => (:bavaria (:munich (:inhabitants 1510378 :size 310.7 :river "Isar"))
      ;;     :berlin (:berlin (:inhabitants 6340918 :size 891.7 :river "Spree")))
      
      (r-getf *geodata* :Italy 3 :Rome)
      
      ;; => (:inhabitants 2749031 :size 1287.36 :river "Tevere")
      
      (r-getf *geodata* 5 3)
      ;; => (:berlin (:inhabitants 6340918 :size 891.7 :river "Spree"))
      
      (r-getf *geodata* :Italy 1 1 5) ; => "Naviglio Grande"
    #+END_SRC
** r-lin
   Function
   #+BEGIN_SRC lisp
     (r-lin min max)
   #+END_SRC
   Random value between [min..max] with linear distribution.
*** Arguments
    | =min= | Number indicationg the minimum value. |
    | =max= | Number indicationg the maximum value. |

*** See also
    - [[r-exp][r-exp]]
** r-lin-dev
   Function
   #+BEGIN_SRC lisp
     (r-lin-dev max)
   #+END_SRC
   return a random deviation factor, the deviation being linearly
   interpolated between 0 for x=0 and [-max..max] for x=1.
** range
   Function
   #+BEGIN_SRC lisp
     (range &rest args)
   #+END_SRC
   Like clojure's range: Return a list of nums from start (inclusive) to
   end (exclusive) by step. Start and step are optional args defaulting
   to 0 and 1 respectively.
   
   Arities:
   
   (range end) 
   
   (range start end) 
   
   (range start end step) 
*** Examples
    #+BEGIN_SRC lisp
      (range 8) ; => (0 1 2 3 4 5 6 7) 
      
      (range 3 9) ; => (3 4 5 6 7 8) 
      
      (range 1 10 2) ; => (1 3 5 7 9)
    #+END_SRC
*** Note
    Unlike clozure's range function, this range function is not
    lazy: As a precaution (range) will return the empty list.
** recall-random-state
   Function
   #+BEGIN_SRC lisp
     (recall-random-state)
   #+END_SRC
** reducing
   Function
   #+BEGIN_SRC lisp
     (reducing fn seq &key key from-end (start 0) end (initial-value nil ivp))
   #+END_SRC
** ref-object
   Class
   #+BEGIN_SRC lisp
     (ref-object)
   #+END_SRC
   A /ref-object/ is a special class used in the /cl-refs/
   package. Its slots shouldn't be accessed or manipulated directly,
   but rather using the public functions of the cl-refs package listed
   below. A ref-object should get instantiated using the [[make-ref][make-ref]] function.
   
   For information how to use ref-objects refer to [[clamps:cl-refs][cl-refs]] in
   the Clamps Packages documentation.
*** See also
    - [[bang-object][bang-object]]
    - [[get-val][get-val]]
    - [[make-bang][make-bang]]
    - [[make-computed][make-computed]]
    - [[make-ref][make-ref]]
    - [[set-val][set-val]]
    - [[watch][watch]]
** regenerate-points
   Function
   #+BEGIN_SRC lisp
     (regenerate-points svg-file &key (fname #p"/tmp/test.svg") (xquantize t) (yquantize t))
   #+END_SRC
** remove-all-buffers
   Function
   #+BEGIN_SRC lisp
     (remove-all-buffers)
   #+END_SRC
   Remove all buffers from registry.
*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[add-buffer][add-buffer]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-id][buffer-id]]
    - [[buffer-name][buffer-name]]
    - [[bufname=][bufname=]]
    - [[clamps-buffer-load][clamps-buffer-load]]
    - [[find-buffer][find-buffer]]
    - [[list-buffers][list-buffers]]
    - [[remove-buffer][remove-buffer]]
** remove-all-channel-midi-cc-fns
   Function
   #+BEGIN_SRC lisp
     (remove-all-channel-midi-cc-fns channel &optional (midi-port *default-midi-port*))
   #+END_SRC
   Remove all functions from *​midi-cc-fns​* for all ccnums of /channel/ of /midi-port/.
*** Arguments
    | =channel= | Integer in the range [1..16] denoting the MIDI channel. |

*** Example
    #+BEGIN_SRC lisp
      (remove-all-channel-midi-cc-fns 1) ; => nil
    #+END_SRC
*** See also
    - [[add-midi-cc-fn][add-midi-cc-fn]]
    - [[#midi-cc-fns][*​​midi-cc-fns​​*]]
    - [[remove-midi-cc-fns][remove-midi-cc-fns]]
    - [[remove-all-midi-cc-fns][remove-all-midi-cc-fns]]
    - [[show-midi-cc-fns][show-midi-cc-fns]]
** remove-all-dsps
   Function
   #+BEGIN_SRC lisp
     (remove-all-dsps)
   #+END_SRC
** remove-all-midi-cc-fns
   Function
   #+BEGIN_SRC lisp
     (remove-all-midi-cc-fns &optional (midi-port *default-midi-port*))
   #+END_SRC
   Remove all functions from *​midi-cc-fns​* for all ccnums and channels.
*** Example
    #+BEGIN_SRC lisp
      (remove-all-midi-cc-fns) ; => nil
    #+END_SRC
*** See also
    - [[add-midi-cc-fn][add-midi-cc-fn]]
    - [[#midi-cc-fns][*​​midi-cc-fns​​*]]
    - [[remove-midi-cc-fns][remove-midi-cc-fns]]
    - [[remove-all-channel-midi-cc-fns][remove-all-channel-midi-cc-fns]]
    - [[show-midi-cc-fns][show-midi-cc-fns]]
** remove-all-midi-controllers
   Function
   #+BEGIN_SRC lisp
     (remove-all-midi-controllers)
   #+END_SRC
   Unregister and delete all currently registered MIDI controller instances.
*** See also
    - [[add-midi-controller][add-midi-controller]]
    - [[list-midi-controllers][list-midi-controllers]]
    - [[find-controller][find-controller]]
    - [[midi-controller][midi-controller]]
    - [[remove-midi-controller][remove-midi-controller]]
** remove-all-rts-hush-hooks
   Function
   #+BEGIN_SRC lisp
     (remove-all-rts-hush-hooks)
   #+END_SRC
   Remove all functions to be called on rts-hush.
*** See also
    - [[add-rts-hush-hook][add-rts-hush-hook]]
    - [[rts-hush][rts-hush]]
    - [[show-rts-hush-hooks][show-rts-hush-hooks]]
** remove-all-triggers
   Function
   #+BEGIN_SRC lisp
     (remove-all-triggers ref &key (unless (lambda (elem) elem nil)))
   #+END_SRC
   Remove all trigger-fns of /ref/ which don't match the /unless/
   predicate.
*** Arguments
    | =ref=    | A [[bang-object][bang-object]].                                                            |
    | =unless= | Predicate called on all trigger-fns to determine which functions to keep. |

*** See also
    - [[add-trigger-fn][add-trigger-fn]]
    - [[remove-trigger-fn][remove-trigger-fn]]
    - [[make-bang][make-bang]]
** remove-buffer
   Function
   #+BEGIN_SRC lisp
     (remove-buffer ref)
   #+END_SRC
   Remove buffer from registry. Return t if buffer was found and
   removed, else return nil.
*** Arguments
    | =buf= | Incudine:buffer, Integer denoting buffer id or filename of buffer. |

*** See also
    - [[clamps:incudine-bufs][incudine-bufs]]
    - [[add-buffer][add-buffer]]
    - [[buffer-dur][buffer-dur]]
    - [[buffer-id][buffer-id]]
    - [[buffer-name][buffer-name]]
    - [[bufname=][bufname=]]
    - [[clamps-buffer-load][clamps-buffer-load]]
    - [[find-buffer][find-buffer]]
    - [[list-buffers][list-buffers]]
    - [[remove-all-buffers][remove-all-buffers]]
** remove-dsp
   Function
   #+BEGIN_SRC lisp
     (remove-dsp id)
   #+END_SRC
   Remove a running Incudine dsp registered with [[add-dsp][add-dsp]].
*** Arguments
    | =id= | Keyword or Symbol identifying the dsp. |

*** See also
    - [[add-dsp][add-dsp]]
    - [[find-dsp][find-dsp]]
    - [[list-dsps][list-dsps]]
** remove-midi-cc-fns
   Function
   #+BEGIN_SRC lisp
     (remove-midi-cc-fns channel ccnum &optional (midi-port *default-midi-port*))
   #+END_SRC
   Remove all functions from *​midi-cc-fns​* for /channel/ and /ccnum/.
*** Arguments
    | =channel= | Integer in the range [1..16] denoting the MIDI channel.            |
    | =ccnum=   | Integer in the range [1..128] denoting the MIDI Controller number. |

*** Example
    #+BEGIN_SRC lisp
      (remove-midi-cc-fns 1 1) ; => nil
    #+END_SRC
*** See also
    - [[add-midi-cc-fn][add-midi-cc-fn]]
    - [[#midi-cc-fns][*​​midi-cc-fns​​*]]
    - [[remove-all-channel-midi-cc-fns][remove-all-channel-midi-cc-fns]]
    - [[remove-all-midi-cc-fns][remove-all-midi-cc-fns]]
    - [[show-midi-cc-fns][show-midi-cc-fns]]
** remove-midi-controller
   Function
   #+BEGIN_SRC lisp
     (remove-midi-controller #:id)
   #+END_SRC
   Unregister and delete the instance of a midi controller with ID /id/.
*** Arguments
    | =id= | Keyword or Symbol used as ID of the instance. |

*** See also
    - [[add-midi-controller][add-midi-controller]]
    - [[list-midi-controllers][list-midi-controllers]]
    - [[find-controller][find-controller]]
    - [[midi-controller][midi-controller]]
    - [[remove-all-midi-controllers][remove-all-midi-controllers]]
** remove-sfz-preset
   Function
   #+BEGIN_SRC lisp
     (remove-sfz-preset name)
   #+END_SRC
   Remove the soundfile map associated with name. This is the opposite of [[load-sfz-preset][load-sfz-preset]].
*** Arguments
    | =name= | Keyword or symbol of the registered preset. |

*** Note
    The soundfile buffers of the samples used in the sfz description
    and the association between the preset name and the sfz file are
    *​not​* removed! Only the association between the preset name, the
    keynums and the buffers are removed.
    
*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
    - [[load-sfz-preset][load-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
    - [[sfz][sfz]]
    - [[sfz-get-range][sfz-get-range]]
    - [[sfz-preset-file][sfz-preset-file]]
    - [[sfz-preset-loaded?][sfz-preset-loaded?]]
** remove-trigger-fn
   Function
   #+BEGIN_SRC lisp
     (remove-trigger-fn ref fn)
   #+END_SRC
   Remove /fn/ from the trigger-fns of /ref/.
*** Arguments
    | =ref=    | A [[bang-object][bang-object]].                                                            |
    | =unless= | Predicate called on all trigger-fns to determine which functions to keep. |

*** See also
    - [[add-trigger-fn][add-trigger-fn]]
    - [[make-bang][make-bang]]
    - [[remove-all-triggers][remove-all-triggers]]
** repeat
   Function
   #+BEGIN_SRC lisp
     (repeat n elem)
   #+END_SRC
   return a list with n occurences of elem. All occurences of elem are
   #'eq to each other.
*** Arguments
    | =n=    | Integer indicationg the number of iterations |
    | =elem= | Any Lisp Object to be repeated.              |

*** Examples
    #+BEGIN_SRC lisp
      (repeat 10 5) ;-> (5 5 5 5 5 5 5 5 5 5)
    #+END_SRC
** repeat-format
   Macro
   #+BEGIN_SRC lisp
     (repeat-format stream expr num)
   #+END_SRC
   format /expr/ /num/ times to /stream/
*** Arguments
    | =stream= | Output stream as in Common Lisp's #'format function. |
    | =expr=   | Expression to format repeatedly.                     |
    | =num=    | Integer number of repetitions.                       |

*** Examples
    #+BEGIN_SRC lisp
      (repeat-format nil "la" 10) ; => "lalalalalalalalalala"
    #+END_SRC
** repeated
   Function
   #+BEGIN_SRC lisp
     (repeated n fn)
   #+END_SRC
   Return a function which applies a given function /fn/ /n/ times onto
   itself. /fn/ must be a function of at least one argument which returns
   one argument. The return value of the function replaces the first
   argument in the next recursive call, leaving all other arguments as
   they were.
*** Arguments
    | =n=  | Integer number of repetitions.    |
    | =fn= | Function to be applied to itself. |

*** Examples
    #+BEGIN_SRC lisp
      (funcall (repeated 4 (lambda (x) (* x 2))) 1)  ; => 16
      
      (funcall (repeated 4 (lambda (x) (* x 2))) 3) ; => 48
    #+END_SRC
*** See also
    - [[do-repeated][do-repeated]]
** reset-logger-stream
   Function
   #+BEGIN_SRC lisp
     (reset-logger-stream)
   #+END_SRC
   Resets /incudine:*​logger-stream​*/ to /*​​error-output​​*/ Call this
   function, if calls to /incudine.util:msg/ don't produce any output in
   the REPL.
*** Note
    This function needs to be called if /Clamps/ is started from a Lisp
    Image.
** restore-envs
   Function
   #+BEGIN_SRC lisp
     (restore-envs)
   #+END_SRC
** restore-tables
   Function
   #+BEGIN_SRC lisp
     (restore-tables)
   #+END_SRC
** reverse-all
   Function
   #+BEGIN_SRC lisp
     (reverse-all list)
   #+END_SRC
   Recursively reverse list and all its sublists.
*** Arguments
    | =list= | The list to recursively reverse. |

*** Example
    #+BEGIN_SRC lisp
      (reverse-all '(1 (2 3) (4 (5 (6 7) 8) 9))) ; => ((9 (8 (7 6) 5) 4) (3 2) 1)
    #+END_SRC
** rfind
   Function
   #+BEGIN_SRC lisp
     (rfind item tree &key (test #'eql))
   #+END_SRC
   Find /item/ by traversing /tree/ recursively until /test/ called on
   /item/ and a tree element returns non-nil. Return item or nil if item
   is not found.
*** Arguments
    | =item=  | Any Common Lisp Object.                                        |
    | =tree=  | A list possibly nested.                                        |
    | =:test= | Function to test for equality between item and a tree element. |

*** Example
    #+BEGIN_SRC lisp
      (rfind 'd '(a (b c (a d c) ((g d (e)) h f)))) ; => d 
    #+END_SRC
** rotate
   Function
   #+BEGIN_SRC lisp
     (rotate seq &optional (n 1))
   #+END_SRC
   Rotate /seq/ by /num/ elems (to the right). /num/ can be negative. If
   /num/ is larger than the list size it will wrap around as if the
   rotation was called recursively num times.
*** Arguments
    | =seq= | Proper sequence to rotate.   |
    | =num= | Integer number of rotations. |

*** Examples
    #+BEGIN_SRC lisp
      (rotate '(dog bird lion cat horse) 1) ; => (horse dog bird lion cat)
      (rotate #(dog bird lion cat horse) -1)  ; => (bird lion cat horse dog)
      
      (rotate '(dog bird lion cat horse) 4733) ; => (lion cat horse dog bird)
    #+END_SRC
** rts
   Function
   #+BEGIN_SRC lisp
     (rts &key (rt-wait 0) (num-midi-ports 2))
   #+END_SRC
   Start the real-time system of Clamps. This functions sets the
   following special variables:
   
   [[#midi-in1][*​​midi-in1​​*]] -- The default Midi Input
   
   [[#midi-out1][*​​midi-out1​​*]] -- The default Midi Output
   
   [[#rts-out][*​​rts-out​​*]] -- The default output for realtime events from Clamps/CM.
   
   It also starts the rt engine of incudine calling
   /incudine:rt-start/ and the midi receivers.
*** Arguments
    | =rt-wait= | Time in seconds to wait before starting. |

*** Note
    
    This command is an replacement of the /rts/ command of CM, described
    [[../cm-dict/index.html#rts-fn.html][here]], so none of the options
    mentioned there or the decription in
    [[../cm-dict/index.html#rts-topic.html][RTS]] apply to Clamps. Other
    related CM functions, like /rts-pause/, /rts-continue/ and /rts-stop/
    also don't work in Clamps.
    
*** See also
    - [[clamps][clamps]]
    - [[rts?][rts?]]
** rts-hush
   Function
   #+BEGIN_SRC lisp
     (rts-hush)
   #+END_SRC
   Functions to be called when audio is hushed. This command gets invoked
   on the /<C-.>/ keyboard shortcut.
   
   In the standard setting this calls ~#'incudine:flush-pending~,
   [[node-free-unprotected][node-free-unprotected]] and [[all-notes-off][all-notes-off]].
*** See also
    - [[add-rts-hush-hook][add-rts-hush-hook]]
    - [[remove-all-rts-hush-hooks][remove-all-rts-hush-hooks]]
    - [[show-rts-hush-hooks][show-rts-hush-hooks]]
** *​rts-out​*
   :PROPERTIES:
   :CUSTOM_ID: rts-out
   :END:
   Variable

   Default clamps Realtime output stream of class
   /<incudine-stream>/.
*** See also
    - [[#midi-out1][*​​midi-out1​​*]]
    - [[rts][rts]]
    - [[rts?][rts?]]
** rts?
   Function
   #+BEGIN_SRC lisp
     (rts? &optional arg)
   #+END_SRC
   Checks if rts is started and running.
*** See also
    - [[rts][rts]]
* S
** save-ats
   Function
   #+BEGIN_SRC lisp
     (save-ats sound file &key (save-phase t) (save-noise t))
   #+END_SRC
   Save /sound/ into //*​ats-file-dir​*/<file>// in binary format. /file/
   must be string with a file name. In case the file already exists it
   gets overwritten
*** Arguments
    | =sound=       | ats-sound to save                                        |
    | =file=        | filename                                                 |
    | =:save-phase= | Boolean indicating whether to save the phase information |
    | =:save-noise= | Boolean indicating whether to save the noise information |

*** See also
    - [[clamps:ats-cuda-display][ats-cuda-display]]
    - [[ats-sound][ats-sound]]
    - [[load-ats][load-ats]]
    - [[track-ats][track-ats]]
** send
   Function
   #+BEGIN_SRC lisp
     (send stream msg)
   #+END_SRC
** set-basedir
   Function
   #+BEGIN_SRC lisp
     (set-basedir basedir)
   #+END_SRC
** set-bpm
   Function
   #+BEGIN_SRC lisp
     (set-bpm bpm)
   #+END_SRC
   Set the tempo in beats per minute for both, CM and Incudine.
*** Arguments
    | =bpm= | Number of beats per minute. |

*** See also
    - [[set-tempo][set-tempo]]
** set-marker
   Generic Function
   #+BEGIN_SRC lisp
     (set-marker object)
   #+END_SRC
   automatically generated reader method
** set-on-data
   Generic Function
   #+BEGIN_SRC lisp
     (set-on-data obj handler)
   #+END_SRC
** set-tempo
   Function
   #+BEGIN_SRC lisp
     (set-tempo bpm)
   #+END_SRC
   Set the tempo in beats per minute for both, CM and Incudine.
*** Arguments
    | =bpm= | Number of beats per minute. |

*** See also
    - [[set-bpm][set-bpm]]
** set-val
   Function
   #+BEGIN_SRC lisp
     (set-val ref value &key (force nil))
   #+END_SRC
   Set the value of ref-object /ref/ to /value/ if different than
   previous value. If /force/ is non-nil, set in any case. Return
   value.
*** Arguments
    | =ref=   | An instance of [[ref-object][ref-object]]                                                                        |
    | =value= | Any value of any type to be set.                                                                 |
    | =force= | A boolean indicating to set the value even if it is eql to the previous value of the ref-object. |

*** See also
    - [[bang-object][bang-object]]
    - [[get-val][get-val]]
    - [[make-computed][make-computed]]
    - [[make-ref][make-ref]]
    - [[ref-object][ref-object]]
    - [[watch][watch]]
** setf-default
   Macro
   #+BEGIN_SRC lisp
     (setf-default sym test default)
   #+END_SRC
** *​sfile-path​*
   :PROPERTIES:
   :CUSTOM_ID: sfile-path
   :END:
   Variable

   List of directories to search recursively for soundfiles.
*** See also
    - [[clamps-buffer-load][clamps-buffer-load]]
    - [[create-lsample][create-lsample]]
** sfz
   Common Music Class
   #+BEGIN_SRC lisp
     (new sfz &key (keynum 60) (amplitude 0) (duration 1) (preset :flute-nv) (oneshot nil) (pan 0.5) (startpos 0) (chan 100))
   #+END_SRC
   Create a sfz Event.
   
   sfz accepts the following slot initializations:
   
   | =:time=      | The output time in seconds, initially unbound.                                                            |
   | =:keynum=    | Keynum in Midicents.                                                                                      |
   | =:amplitude= | Amplitude in dB, the range [-100..0] corresponding to linear values [0..1].                               |
   | =:duration=  | Duration in seconds.                                                                                      |
   | =:preset=    | Keyword or symbol of a registered preset name.                                                            |
   | =:oneshot=   | Boolean denoting not to use loop playback.                                                                |
   | =:pan=       | Number in the range /[0..1]/ defining equal power panning between the two outputs of the dsp on playback. |
   | =:startpos=  | The startposition in the sample in seconds.                                                               |
   | =:chan=      | The channel (layer) used in svg output.                                                                   |
*** Examples
    #+BEGIN_SRC lisp
        (new sfz)
        ;; => #i(sfz keynum 60 amplitude 1 duration 1 preset :flute-nv
        ;;           play-fn nil pan 0.5 startpos 0 chan 100)
      
        ;; the following code should send 1 second of a flute middle C sound
        ;; to the first two oulets of incudine:
      
        (output (new sfz)) ; => ; No value
      
        ;; => loading :flute-nv from ~/quicklisp/local-projects/clamps/extra/snd/sfz/Flute-nv/000_Flute-nv.sfz
        ;; ; No values
      
        (loop
           for idx below 200
          for x = (/ idx 199)
          for time = 0 then (+ time (n-exp (interp x 0 0  0.3 1  1 0) 0.01 0.1))
          do (sprout
              (new sfz
                :time time
                :keynum (+ 65.5 (random (n-lin (interp x 0 0 1 1) 1 5)))
                :duration (+ 0.5 (random 2.0))
                :amplitude (n-lin (interp x 0 0 0.8 0 1 1) -12 -24))))
      
        ;; => nil
    #+END_SRC
*** See also
    - [[clamps:cm-sfz][cm-sfz]]
    - [[dict:midi][midi]]
** sfz->lsample
   Function
   #+BEGIN_SRC lisp
     (sfz->lsample sfz-entry dir &key oneshot)
   #+END_SRC
   Convert an entry of a sfz file into a lsample.
*** Arguments
    | =sfz-entry= | Instance of sfz class.                                     |
    | =dir=       | Pathname or String denoting the directory of the sfz file. |
    | =:oneshot=  | Boolean denoting whether not to loop the playback.         |

*** See also
    - [[sfz][sfz]]
    - [[lsample][lsample]]
** *​sfz-file-path​*
   :PROPERTIES:
   :CUSTOM_ID: sfz-file-path
   :END:
   Variable

   List of directories to search recursively for /.sfz/ files.
*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[load-sfz-preset][load-sfz-preset]]
** sfz-get-range
   Function
   #+BEGIN_SRC lisp
     (sfz-get-range ref)
   #+END_SRC
   Get the keynum range of a sfz preset or a sfz file denoted by /ref/.
*** Arguments
    | =ref= | String, Keynum or Symbol reference the sfz preset. |

*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
    - [[load-sfz-preset][load-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
    - [[sfz][sfz]]
    - [[sfz-preset-file][sfz-preset-file]]
    - [[sfz-preset-loaded?][sfz-preset-loaded?]]
** sfz-preset-buffers
   Function
   #+BEGIN_SRC lisp
     (sfz-preset-buffers preset pitch)
   #+END_SRC
   Return all buffers of sfz /preset/ for /pitch/ in a list.
*** Arguments
    | =preset= | Symbol or Keynum denoting id of a registered preset.             |
    | =pitch=  | Integer in the range [0..127] denoting keynum of sfz definition. |

*** See also
    - [[sfz-preset-lsamples][sfz-preset-lsamples]]
    - [[get-sfz-preset][get-sfz-preset]]
** sfz-preset-file
   Function
   #+BEGIN_SRC lisp
     (sfz-preset-file preset)
   #+END_SRC
   Return the full path of /preset/.
*** Arguments
    | =preset= | Keyword or symbol of a registered sfz preset. |

*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
    - [[load-sfz-preset][load-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
    - [[sfz][sfz]]
    - [[sfz-get-range][sfz-get-range]]
    - [[sfz-preset-loaded?][sfz-preset-loaded?]]
** sfz-preset-loaded?
   Function
   #+BEGIN_SRC lisp
     (sfz-preset-loaded? preset)
   #+END_SRC
   Predicate to test if sfz preset is loaded.
*** Arguments
    | =preset= | Keyword or symbol of registered preset. |

*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      ;;; Directly after Clamps startup:
      
      (sfz-preset-loaded? :flute-nv) ;; => nil
      
      (output (new sfz))
      ;; => loading :flute-nv from ~/quicklisp/local-procects/clamps/extra/snd/sfz/Flute-nv/000_Flute-nv.sfz
      ;; No values
      
      (sfz-preset-loaded? :flute-nv) ;; => t
      #+END_SRC
    #+END_SRC
*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
    - [[load-sfz-preset][load-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
    - [[sfz][sfz]]
    - [[sfz-get-range][sfz-get-range]]
    - [[sfz-preset-file][sfz-preset-file]]
** sfz-preset-lsamples
   Function
   #+BEGIN_SRC lisp
     (sfz-preset-lsamples preset pitch)
   #+END_SRC
   Return all lsamples of sfz /preset/ for /pitch/ in a list.
*** Arguments
    | =preset= | Symbol or Keynum denoting id of a registered preset. |
    | =pitch=  | Non Negative Number in the range [0..127].           |

*** See also
    - [[get-sfz-preset][get-sfz-preset]]
    - [[sfz-preset-buffers][sfz-preset-buffers]]
** show-midi-cc-fns
   Function
   #+BEGIN_SRC lisp
     (show-midi-cc-fns channel ccnum)
   #+END_SRC
   Show all functions stored in *​midi-cc-fns​* for /channel/ and /ccnum/.
*** Arguments
    | =channel= | Integer in the range [1..16] denoting the MIDI channel.            |
    | =ccnum=   | Integer in the range [1..128] denoting the MIDI Controller number. |

*** Example
    #+BEGIN_SRC lisp
      (show-midi-cc-fns 1 1) ; => nil
      
      ;; Output in the REPL:
      ;; cc-fns of channel 1, ccnum 1: (#<function (lambda (ccval)) {564E441B}>)
    #+END_SRC
*** See also
    - [[add-midi-cc-fn][add-midi-cc-fn]]
    - [[#midi-cc-fns][*​​midi-cc-fns​​*]]
    - [[remove-midi-cc-fns][remove-midi-cc-fns]]
    - [[remove-all-channel-midi-cc-fns][remove-all-channel-midi-cc-fns]]
    - [[remove-all-midi-cc-fns][remove-all-midi-cc-fns]]
** show-rts-hush-hooks
   Function
   #+BEGIN_SRC lisp
     (show-rts-hush-hooks)
   #+END_SRC
   Show all functions invoked on rts-hush.
*** See also
    - [[add-rts-hush-hook][add-rts-hush-hook]]
    - [[remove-all-rts-hush-hooks][remove-all-rts-hush-hooks]]
    - [[rts-hush][rts-hush]]
** *​sine1024​*
   :PROPERTIES:
   :CUSTOM_ID: sine1024
   :END:
   Variable

   Incudine buffer of length 1024 containing one period of a sine wave.
*** Example
      #+BEGIN_SRC lisp
      (plot *sine1024*)
      ;; => #<incudine:buffer :FRAMES 1024 :CHANNELS 1 :SR 44100.0>
      #+END_SRC
      
      #+attr_html: :width 50%
      #+CAPTION: *​sine1024​* buffer
      [[./img/sine-plot.svg]]
*** See also
    - [[#hanning1024][*​​hanning1024​​*]]
** slurp
   Function
   #+BEGIN_SRC lisp
     (slurp file)
   #+END_SRC
   Return contents of file as a list of all lines read individually by
   the lisp reader.
** slurp-string
   Function
   #+BEGIN_SRC lisp
     (slurp-string file)
   #+END_SRC
   Return contents of file as a string.
** spit
   Function
   #+BEGIN_SRC lisp
     (spit seq &key (outfile "/tmp/test.lisp"))
   #+END_SRC
   Print /seq/ to /outfile/, each element on a new line.
** splice
   Function
   #+BEGIN_SRC lisp
     (splice list &key (key #'first) (test #'eq))
   #+END_SRC
   Return a list of all sublists containing elements mutually satisfying
   the /test/ predicate.
*** Arguments
    | =list= | List to splice                                           |
    | =key=  | Function applied to each element of list before testing. |
    | =test= | Function to determine equality between two elements.     |

*** Examples
    #+BEGIN_SRC lisp
      (splice '((0 1) (4 7) (7 2) (0 3) (4 5) (1 3)))
       ; => (((0 1) (0 3)) ((4 7) (4 5)) ((7 2)) ((1 3)))
      
      (splice '((0 1) (4 7) (7 2) (0 3) (4 5) (1 7)) :key #'second)
       ; => (((0 1)) ((4 7) (1 7)) ((7 2)) ((0 3)) ((4 5)))
    #+END_SRC
** standard-pitch
   Function
   #+BEGIN_SRC lisp
     (standard-pitch)
   #+END_SRC
   Return the tuning reference of A4 in Hz. Setfable.
*** Examples
    #+BEGIN_SRC lisp
      (standard-pitch) ; => 440
      
      (setf (standard-pitch) 415) ; => 415
      
      (standard-pitch) ; => 415
    #+END_SRC
** start-doc-acceptor
   Function
   #+BEGIN_SRC lisp
     (start-doc-acceptor)
   #+END_SRC
   Start the doc acceptor for online documentation. This is done
   automatically on startup to make the clamps documentation
   accessible at the URL /https://localhost:8282/.
** start-gui
   Function
   #+BEGIN_SRC lisp
     (start-gui &key (port 54619) (gui-base (asdf:system-source-directory :clog-dsp-widgets)) (open t))
   #+END_SRC
** start-midi-engine
   Function
   #+BEGIN_SRC lisp
     (start-midi-engine &key (num-ports 2))
   #+END_SRC
   open midi ports and start realtime thread.
** start-midi-receive
   Function
   #+BEGIN_SRC lisp
     (start-midi-receive midi-port)
   #+END_SRC
   Start the clamps generic midi handler and all registered MIDI responders
   of /midi-port/.
*** Arguments
    | =midi-port= | Instance of a midi-port struct. |

*** See also
    - [[stop-midi-receive][stop-midi-receive]]
** start-osc-midi-receive
   Function
   #+BEGIN_SRC lisp
     (start-osc-midi-receive local-midi-in &key (port 4711))
   #+END_SRC
   start osc on localhost:port and its receivers.
** stop-midi-receive
   Function
   #+BEGIN_SRC lisp
     (stop-midi-receive midi-port)
   #+END_SRC
   Stop the clamps generic midi handler and remove all registered MIDI
   responders of input stream /input/.
*** Arguments
    | =midi-port= | Instance of a midi-port struct. |

*** See also
    - [[start-midi-receive][start-midi-receive]]
** stop-osc-midi-receive
   Function
   #+BEGIN_SRC lisp
     (stop-osc-midi-receive &optional local-midi-in)
   #+END_SRC
** str-concat
   Function
   #+BEGIN_SRC lisp
     (str-concat &rest args)
   #+END_SRC
   concatenate strings.
*** Arguments
    | =args= | one or more strings to concatenate |

*** Example
    #+BEGIN_SRC lisp
      (str-concat "Hello" " World") ; => "Hello World"
    #+END_SRC
** stream
   Structure

** stream-open?
   Function
   #+BEGIN_SRC lisp
     (stream-open? s)
   #+END_SRC
** stream-p
   Function
   #+BEGIN_SRC lisp
     (stream-p object)
   #+END_SRC
** subseqx
   Function
   #+BEGIN_SRC lisp
     (subseqx seq start &optional end)
   #+END_SRC
   Like #'subseq, but allowing negative values for /end/, indicating the
   number of elems at the end of /seq/ to be omitted.
*** Arguments
    | =seq=   | A Common Lisp Sequence.                                                                                                                                                                                   |
    | =start= | Non Negative Integer denoting starting index of seq.                                                                                                                                                      |
    | =end=   | Integer denoting last element's position in seq. If positive, the last element is /(elt seq (1- end))/. If end is negative, /(abs end)/ denotes the number of elements to be omitted from the end of seq. |

*** Examples
    #+BEGIN_SRC lisp
      (subseqx '(a b c d e f g) 0 3) ; => (a b c)
      
      (subseqx '(a b c d e f g) 0 -2) ; => (a b c d e)
    #+END_SRC
** svg->browser
   Function
   #+BEGIN_SRC lisp
     (svg->browser svg-file &key (bar-lines t) (staff-systems t) (piano-roll nil) (scale 1) (timescale 1/32) (inverse nil) (reload t) timeshift)
   #+END_SRC
   Display =svg-file= in the SVG Player Gui, located at
   /<clamps-base-url>/svg-display/.
*** Arguments
    | =svg-file=       | String naming the svg-file to display/play. The filename is interpreted relative to the /<clamps-gui-root>/svg/ directory. |
    | =:bar-lines=     | Boolean indicating whether to display barlines.                                                                            |
    | =:staff-systems= | Boolean indicating whether to display staff systems.                                                                       |
    | =:piano-roll=    | Boolean indicating whether to display a piano roll.                                                                        |
    | =:scale=         | Positive Number denoting the zoom factor of the graphic.                                                                   |
    | =:timescale=     | Positive number denoting The timescale for playback.                                                                       |
    | =:timeshift=     | Positive number denoting The timescale for playback.                                                                       |
    | =:inverse=       | 0 or 1 indicating inverse colors.                                                                                          |
    | =:reload=        | Boolean indicating whether to reload the html page                                                                         |
    | =:timeshift=     | Number denoting an optional timeshift (will also be scaled by :timescale).                                                 |

*** Example
    #+BEGIN_SRC lisp
      (events
       (loop
         for i below 10
         collect (new midi :time (* 0.1 i) :keynum (between 60 72) :duration 0.1))
       (svg-gui-path "test.svg"))
      
      (svg->browser "test.svg")
      
      ;; Then open a browser at http://127.0.0.1:54619/svg-display
    #+END_SRC
*** See also
    - [[clamps:clamps-svg.rts][clamps-svg.rts]]
    - [[svg-gui-path][svg-gui-path]]
** svg->lines
   Function
   #+BEGIN_SRC lisp
     (svg->lines &key (infile #p"/tmp/test.svg") (timescale 1) (xquantize nil) (yquantize nil) (layer "events") group? layer?)
   #+END_SRC
   extract all line objects in the layer "Events" of svg infile.
   Also removes duplicates and flattens subgroups. Lines are property
   lists containing all svg attributes.
** svg->points
   Function
   #+BEGIN_SRC lisp
     (svg->points &key (infile #p"/tmp/test.svg") (timescale 1) (xquantize t) (yquantize t) (x-offset 0) (layer "punkte"))
   #+END_SRC
   extract all circle objects (points) in the layer "Punkte" of svg infile.
   Also removes duplicates and flattens subgroups. Points are simple
   two-element lists containing x and y coordinates. The y coordinate is
   supposed to be a midifloat value, x ist translated into secs/beats.
** svg-clone
   Class

** svg-cm-line
   Class

** svg-collect-lines
   Function
   #+BEGIN_SRC lisp
     (svg-collect-lines layer parse-state &key (timescale 1) (x-offset 0) (xquantize nil) (yquantize nil) layer?)
   #+END_SRC
   return a list of svg-cm-line instances of layer with a given parse-state.
** svg-file
   Common Music Output Class

   Output to a SVG file.
   
   svg-file accepts the following keys:
   
   | =:global=           | global parameters supplied to the svg-export backend.                                                           |
   | =:piano-roll-vis=   | Boolean denoting whether Piano Roll display is initially visible. Defaults to /t/.                              |
   | =:staff-system-vis= | Boolean denoting whether Staff Systems are initially visible. Defaults to /t/.                                  |
   | =:bar-lines-vis=    | Boolean denoting whether Barlines are initially visible. Defaults to /t/.                                       |
   | =:showgrid=         | Boolean denoting whether a grid is initially visible. Defaults to /t/.                                          |
   | =:x-scale=          | Number denoting a x scaling factor. Default is 1.                                                               |
   | =:barstepsize=      | Positive Integer denoting the number increment for a drawn barline.                                             |
   | =:startbar=         | Integer denoting the number of the first bar.                                                                   |
   | =:barmultiplier=    | Integer denoting a scaling factor for the bar numbers.                                                          |
   | =:width=            | Positive Integer denoting the width of the SVG file. Default is the minimum width needed to display all events. |
*** Examples
    #+BEGIN_SRC lisp
      (events
       (loop
         for time from 0 by 1/16
         for keynum in (integrate '(60 2 2 1 2 2 2 1))
         collect (new sfz :time time :keynum keynum :duration 1/16))
              "/tmp/test.svg"
              :piano-roll-vis nil
              :showgrid t
              :x-scale 16)
      ;; => "/tmp/test.svg"
    #+END_SRC
   #+attr_html: :width 30%
   #+CAPTION: Detail of svg-file generated with the Lisp code above
   [[./img/svg-file-example-01.png]]
   
   #+BEGIN_SRC lisp
   (events
    (loop
      for time from 0 by 1/16
      for keynum in (integrate '(60 2 2 1 2 2 2 1))
      collect (new sfz :time time :keynum keynum :duration 1/16))
           "/tmp/test.svg"
           :piano-roll-vis t
           :staff-system-vis nil
           :bar-lines-vis nil
           :showgrid nil
           :x-scale 16)
   ;; => "/tmp/test.svg"
   #+END_SRC
   
   #+attr_html: :width 30%
   #+CAPTION: Detail of svg-file generated with the Lisp code above
   [[./img/svg-file-example-02.png]]
   
   #+BEGIN_SRC lisp
   (events
    (loop
      for time from 0 below 4 by 1/4
      with keynum = (new cycle :of (integrate '(60 2 2 1 2 2 2 1)))
      collect (new sfz :time time :keynum (next keynum) :duration 1/4))
           "/tmp/test.svg"
           :piano-roll-vis t
           :staff-system-vis nil
           :barmultiplier 1
           :barstepsize 1
           :bar-lines-vis t
           :startbar 1
           :showgrid nil
           :x-scale 16)
   ;; => "/tmp/test.svg"
   #+END_SRC
   
   #+attr_html: :width 100%
   #+CAPTION: Detail of svg-file generated with the Lisp code above
   [[./img/svg-file-example-04.png]]
   
   #+BEGIN_SRC lisp
   (events
    (loop
      for time from 0 below 16 by 1/4
      with keynum = (new cycle :of (integrate '(60 2 2 1 2 2 2 1)))
      collect (new sfz :time time :keynum (next keynum) :duration 1/4))
           "/tmp/test.svg"
           :piano-roll-vis t
           :staff-system-vis nil
           :barstepsize 5
           :barmultiplier 5
           :bar-lines-vis t
           :startbar 0
           :showgrid nil
           :x-scale 16)
   #+END_SRC
   #+attr_html: :width 100%
   #+CAPTION: Detail of svg-file generated with the Lisp code above
   [[./img/svg-file-example-05.png]]
*** See also
    - [[dict:midi][midi]]
** svg-gui-path
   Function
   #+BEGIN_SRC lisp
     (svg-gui-path &optional file)
   #+END_SRC
   Return the full path of SVG file /file/ in the current GUI or the
   base-gui-path of svg files if /file/ is not supplied.
*** Arguments
    | =file= | A String designating the filename of the SVG file. |

*** Examples
    #+BEGIN_SRC lisp
      (svg-gui-path)
      ;; => #P"/tmp/www/svg/"
      
      (svg-gui-path "test.svg")
      ;; => #P"/tmp/www/svg/test.svg"
    #+END_SRC
*** See also
    - [[clamps-gui-root][clamps-gui-root]]
** svg-rect
   Class

** system-version
   Function
   #+BEGIN_SRC lisp
     (system-version system-designator)
   #+END_SRC
   Return the version of an installed /asdf/ system or nil if not
   bound/existent.
*** Arguments
    | =system-designator= | A designator acceptable to /asdf:find-system/ |

*** Examples
    #+BEGIN_SRC lisp
      (system-version :cm) ; => "2.12.0"
    #+END_SRC
* T
** tempo->svg-timescale
   Function
   #+BEGIN_SRC lisp
     (tempo->svg-timescale arg1 &optional arg2)
   #+END_SRC
   Convert tempo setting into the duration of one 16th note
   (in seconds) for svg playback in the clamps Gui.
*** Arguments
    | =arg1= | Number denoting either a rhythm value (1/4 for a quarter note), or a bpm value if arg2 isn't supplied. |
    | =arg2= | Number denoting the beats per minute (bpm).                                                            |

*** Examples
    #+BEGIN_SRC lisp
      (tempo->svg-timescale 1/4 60) -> 1/4
      
      (tempo->svg-timescale 1/2 60) -> 1/8
      
      (tempo->svg-timescale 60) -> 1/4
    #+END_SRC
** text-anchor
   Generic Function
   #+BEGIN_SRC lisp
     (text-anchor object)
   #+END_SRC
   automatically generated reader method
** toggle-ref-fn
   Function
   #+BEGIN_SRC lisp
     (toggle-ref-fn ref &optional (num-states 2))
   #+END_SRC
   Return a function of no arguments which cycles the values of ref-cell
   /ref/ between 0 and (1- /num-states/).
*** Arguments
    | =ref= | A [[ref-object][ref-object]] or [[bang-object][bang-object]]. |

** toggle-ref-watch
   Function
   #+BEGIN_SRC lisp
     (toggle-ref-watch ref &optional (modulo 2))
   #+END_SRC
   Install a function to cycle the value of /ref/ between 0 and (1-
   /modulo/ on trigger. Returns its uninstall function.
** toggle-slot
   Macro
   #+BEGIN_SRC lisp
     (toggle-slot slot)
   #+END_SRC
** track-ats
   Function
   #+BEGIN_SRC lisp
     (track-ats file &rest args &key (start 0.0) (duration nil) (lowest-frequency 20) (highest-frequency 20000.0) (frequency-deviation 0.1) (window-cycles 4) (window-type 'blackman-harris-4-1) (hop-size 1/4) (fft-size nil) (lowest-magnitude (db-amp -60)) (track-length 3) (min-segment-length 3) (last-peak-contribution 0.0) (smr-continuity 0.0) (amp-threshold nil) (residual nil) (par-energy t) (optimize t) (debug nil) (verbose nil) (force-m nil) (force-window nil))
   #+END_SRC
   Analyze a soundfile /file/ and return its [[ats-sound][ats-sound]] structure. The
   soundfile will be searched in all paths contained in [[#sfile-path][*​​sfile-path​​*]] and
   its subdirectories.
*** Arguments
    | =file=                    | String denoting filename of the soundfile within *​​ats-snd-dir​​* to analyze.                                                                                                             |
    | =:start=                  | Number indicating time offset into the soundfile in seconds.                                                                                                                           |
    | =:duration=               | Number indicating the duration to analyze or nil for end of soundfile.                                                                                                                 |
    | =:lowest-frequency=       | Number indicating the lowest frequency to capture (determines Fourier Window width)                                                                                                    |
    | =:highest-frequency=      | Number indicating the highest frequency to capture. :frequency deviation - Number indicating the maximum frequency deviation of successive frames to be considered for the same track. |
    | =:window-cycles=          | Positive Integer denoting the overlap factor of successive analysis windows.                                                                                                           |
    | =:window-type=            | The amplitude envelope type to use for each analysis window.                                                                                                                           |
    | =:hop-size=               | Positive Integer denoting the hop-size of successive analysis windows.                                                                                                                 |
    | =:fft-size=               | Positive Integer denoting the FFT size or nil, denoting to calculate the FFT size based on the lowest frequency.                                                                       |
    | =:lowest-magnitude=       | Positive Integer in the range [0..1] setting the threshold for analysis peaks to be considered.                                                                                        |
    | =:track-length=           | Positive Integer.                                                                                                                                                                      |
    | =:min-segment-length=     | Positive Integer indicating the minimum number of successive segments within the frequency deviation to qualify for a track.                                                           |
    | =:last-peak-contribution= | Number.                                                                                                                                                                                |
    | =:SMR-continuity=         | Number.                                                                                                                                                                                |
    | =:amp-threshold=          | Boolean.                                                                                                                                                                               |
    | =:residual=               | String denoting the filename for the residual noise soundfile or nil if residual noise shouldn't get calculated.                                                                       |
    | =:par-energy=             | Boolean indicating whether to distribute the residual noise to the partials.                                                                                                           |
    | =:optimize=               | Boolean indicating whether to optimize the results.                                                                                                                                    |
    | =:debug=                  | Boolean flag to show debug info in the REPL.                                                                                                                                           |
    | =:verbose=                | Boolean flag for verbose output.                                                                                                                                                       |
    | =:force-M=                | Boolean.                                                                                                                                                                               |
    | =:force-window=           | Boolean.                                                                                                                                                                               |

*** See also
    - [[clamps:ats-cuda-display][ats-cuda-display]]
    - [[ats-sound][ats-sound]]
    - [[load-ats][load-ats]]
    - [[save-ats][save-ats]]
** transform
   Generic Function
   #+BEGIN_SRC lisp
     (transform object)
   #+END_SRC
   automatically generated reader method
** trigger
   Generic Function
   #+BEGIN_SRC lisp
     (trigger obj)
   #+END_SRC
** trigger-fns
   Generic Function
   #+BEGIN_SRC lisp
     (trigger-fns object)
   #+END_SRC
   automatically generated reader method
* U
** ucopy
   Generic Function
   #+BEGIN_SRC lisp
     (ucopy sym)
   #+END_SRC
   Copy an instance of a class recursively.
** unregister-element
   Function
   #+BEGIN_SRC lisp
     (unregister-element element bindings)
   #+END_SRC
   Remove element from all bindings, removing the binding from the
   hash-table if its element-list is empty.
** unwatch
   Generic Function
   #+BEGIN_SRC lisp
     (unwatch object)
   #+END_SRC
   automatically generated reader method
** update-all-controllers
   Function
   #+BEGIN_SRC lisp
     (update-all-controllers midi-port)
   #+END_SRC
   call [[update-hw-state][update-hw-state]] on all registered midi-controllers of
   /midi-port/.
** update-hw-state
   Generic Function
   #+BEGIN_SRC lisp
     (update-hw-state instance)
   #+END_SRC
   Update the state of a Hardware Midicontroller and related guis by
   resetting all values of /instance/ to their current values, effecting
   a resend of all values to the midi outputs and the guis. This can be
   used to restore a hardware controller's state after reconnecting.
*** Arguments
    | =instance= | An instance of a class or subclass of [[midi-controller][midi-controller]]. |

*** See also
    - [[clamps:cl-midictl][cl-midictl]]
** update-preset-buttons
   Function
   #+BEGIN_SRC lisp
     (update-preset-buttons controller)
   #+END_SRC
   React to bank changes, etc. by updating the value of all preset
   buttons.
* V
** v-append
   Macro
   #+BEGIN_SRC lisp
     (v-append (v n &optional (tail '())) &rest body)
   #+END_SRC
   Return a list of /n/ elems appended to each other and prepended to
   /tail/ by evaluating /body/ /n/ times with the symbol /v/ bound to the
   iteration index in the lexical scope of body. The body has to return a
   list.
*** Arguments
    | =v=    | Symbol used as variable name.                               |
    | =n=    | Integer indicating the number of iterations.                |
    | =body= | Macro body being evaluated n times. Needs to return a list. |

*** Examples
    #+BEGIN_SRC lisp
      (v-append (n 5) (list :num (* n n))) ;-> (:num 0 :num 1 :num 4 :num 9 :num 16)
    #+END_SRC
*** See also
    - [[call/collecting][call/collecting]]
    - [[v-collect][v-collect]]
** v-collect
   Macro
   #+BEGIN_SRC lisp
     (v-collect (v n &optional (tail '())) &rest body)
   #+END_SRC
   Return a list of /n/ elems prepended to /tail/ by evaluating /body/
   /n/ times with the symbol /v/ bound to the iteration index in the
   lexical scope of body.
*** Arguments
    | =v=    | Symbol used as variable name.                |
    | =n=    | Integer indicating the number of iterations. |
    | =body= | Function body being evaluated n times.       |

*** Examples
    #+BEGIN_SRC lisp
      (v-collect (n 10) (* n n)) ;-> (0 1 4 9 16 25 36 49 64 81)
    #+END_SRC
*** See also
    - [[call/collecting][call/collecting]]
    - [[v-append][v-append]]
* W-Y
** watch
   Function
   #+BEGIN_SRC lisp
     (watch fn)
   #+END_SRC
   Call /fn/ whenever a value accessed using [[get-val][get-val]] in the body of
   the function is changed.
   
   /watch/ returns a function to remove the relation, /watch/ has
   established. Refer to the chapter [[clamps:cl-refs][cl-refs]] in the Clamps
   Packages documentation for examples.
*** Arguments
    | =fn= | Function of no arguments to call |

*** See also
    - [[get-val][get-val]]
    - [[make-computed][make-computed]]
    - [[make-ref][make-ref]]
    - [[set-val][set-val]]
** with-curr-dir
   Macro
   #+BEGIN_SRC lisp
     (with-curr-dir (dir) &body body)
   #+END_SRC
   set the cwd to dir in the body, return the result of body after
   resetting the cwd.
** with-exp-midi-fn
   Macro
   #+BEGIN_SRC lisp
     (with-exp-midi-fn (min max) &body body)
   #+END_SRC
   return closure with ipfn bound to an exponential interpolation of
   the input range 0..127 between min and max.
** with-gnuplot-instance
   Macro
   #+BEGIN_SRC lisp
     (with-gnuplot-instance (stream &rest args) &body body)
   #+END_SRC
   start an external gnuplot process with a data input stream open for the extent of body.
   
   stream is bound to gnuplot's input stream. Printing to it is
   equivalent to printing into a file read by gnuplot as a dataset with
   its plot command.
   
   args are arguments sent to #'launch-gnuplot. 
   
   Leaving the macro is equivalent to gnuplot reaching EOF when reading
   an external dataset.
** with-gui-update-off
   Macro
   #+BEGIN_SRC lisp
     (with-gui-update-off (instance) &body body)
   #+END_SRC
   Evaluate code of /body/ in the context of the gui-update-off slot of
   /instance/ set to t. After the body has evaluated, the gui-update-off
   slot is set to its previous value before entering body.
*** Arguments
    | =instance= | Instance of type [[midi-controller]]. |
    | =body=     | Zero or more lisp forms.          |

** with-lin-midi-fn
   Macro
   #+BEGIN_SRC lisp
     (with-lin-midi-fn (min max) &body body)
   #+END_SRC
   Return closure with ipfn bound to a linear interpolation of the
   input range 0..127 between min and max.
** with-props
   Macro
   #+BEGIN_SRC lisp
     (with-props vars proplist &body body)
   #+END_SRC
   Like with-slots but using a property list instead of a class
   instance. The properties in the /proplist/ to be used need to have a
   symbol or a keyword as a key. /vars/ is a list of symbols bound to the
   corresponding property values in the lexical scope of /body/. Each
   element of vars corresponds to a key in proplist either being the
   binding symbol itself or a keyword, derived by prepending a colon to
   the binding symbol.
*** Arguments
    | =vars=     | List of symbols of the Properties to use in the lexical scope of body. |
    | =proplist= | Property list containing bound properties.                             |
    | =body=     | The body in which the vars are bound.                                  |

*** Example
    #+BEGIN_SRC lisp
      (with-props (a b c) '(:a 1 :b 2 c 3)
        (list a b c))
      ;; => (1 2 3)
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist][do-proplist]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-prop][get-prop]]
    - [[get-props-list][get-props-list]]
    - [[map-proplist][map-proplist]]
** with-shadowed-variable
   Macro
   #+BEGIN_SRC lisp
     (with-shadowed-variable (var) &rest body)
   #+END_SRC
   Shadow /var/ in the local scope of /body/. /var/ should be bound
   before entering /with-shadowed-variable/.
*** Arguments
    | =var=  | Symbol of variable to shadow         |
    | =body= | Body for the scope of the shadowing. |

*** Example
    #+BEGIN_SRC lisp
      (defvar *myvar* 2) ; => *myvar*
      
      (defun return-myvar ()
       *myvar*)
      
      (with-shadowed-variable (*myvar*)
        (setf *myvar* 10)
        (return-myvar))
      
      ;; => 10
      
      *myvar* ; => 2
    #+END_SRC
** with-svg-file
   Macro
   #+BEGIN_SRC lisp
     (with-svg-file (svg-file &rest keys) &body body)
   #+END_SRC
** with-unwatched
   Macro
   #+BEGIN_SRC lisp
     (with-unwatched bindings &body body)
   #+END_SRC
   all #'get-val forms contained in bindings are not watched.
* Z
** zoom
   Generic Function
   #+BEGIN_SRC lisp
     (zoom object)
   #+END_SRC
   automatically generated reader method
